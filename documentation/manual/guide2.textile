h1. A first iteration for the data model

Here we will start to write the model part of our blog engine.

h2. <a>Introduction to JPA</a>

The model layer has a central position in a play application (and in fact in all well designed application). It is the domain-specific representation of the information on which the application operates. As we want to create a blog engine the model layer will certainly contains classes like User, Post and Comment.

Because we want that most of data manipulated by the model objects survive between application restart we have to save them in a persistent datastore. A common choice to store data is to use a relational database. But because Java is an object oriented language we will use an 'Object Relational Mapper' to help to reduce the impedance mismatch.

JPA is a Java specification that define a standard API for object relational mapping. As implementation of JPA, play uses the famous Hibernate framework. One advantage of using JPA over the standard Hibernate API is that all the 'mapping' in directly declared in the Java objects.

If you have ever used Hibernate or JPA before you will be surprised by the simplicity added by play at this level. No need to configure anything; JPA just work out of the box with play.

If you don't know JPA, you can "read some of these simple presentation":http://java.sun.com/javaee/5/docs/tutorial/doc/bnbpz.html before to continue.

h2. <a>Starting by the User class</a>

We will start to code the blog engine by creating the User class. Create a new file **/yabe/app/models/User.java**, and declare a first implementation of the User class :

bc. package models;
 
import java.util.*;
import javax.persistence.*;
 
import play.db.jpa.*;
 
@Entity
public class User extends Model {
 
    public String email;
    public String password;
    public String fullname;
    public boolean isAdmin
    
    public User(String email, String password, String fullname) {
        this.email = email;
        this.password = password;
        this.fullname = fullname;
    }
 
}

The **@Entity** annotation mark this class as a managed JPA entity and the Model superclass automatically provides a set of usefull JPA helper that we will discover later. All fields of this class will be automatically persisted to the database. 

If you have already used JPA before, you know that every JPA entity must provide an @Id property but the Model superclass provides an automatically generated numeric id, that is a pretty good default in most cases. 

Now if youâ€™re a Java developer with any experience at all, warning sirens are probably clanging like mad at the sight of a public variable. In Java (as in other object-oriented languages), best practice says to make all fields private and provide accessors and mutators. This is to promote encapsulation, a concept critical to object oriented design. But in fact, play take care of that for you and will automatically generate getter and setter for you while preserving encapsulation; we will see how that work later in this tutorial.

You can now refresh the application homepage, to see the result. In fact, unless you made a mistake, you should see nothing specific: play has automatically compiled and loaded the User class, but this does not provide any feature to the application.

h2. <a>Writing the first test</a>

A good way to test the newly created User class, is to write a JUnit test case. It will allow to incrementally complete the application model and test that all is going fine.

To run a test case, you need to start the application in a special 'test' mode. Stop the currently running application, open a command line and type :

bc. ~$ play test

!images/guide2-0!

The 'play test' command is almost the same than 'play run', except that it load a test runner module that allow to run test suite directly from a browser. 

Open a browser to the "http://localhost:9000/@tests":http://localhost:9000/@tests URL to see the test runner. You can try to select all the default tests and run them; all should be green... but these default tests does not test really anything.

!images/guide2-1!

To test the model part of the application we will use a JUnit test. As you see a default BasicTests.java already exists, so let's open it (**/yabe/test/BasicTest.java**):

bc. import org.junit.*;
import play.test.*;
import models.*;
 
public class BasicTest extends UnitTest {
 
    @Test
    public void aVeryImportantThingToTest() {
        assertEquals(2, 1 + 1);
    }
 
}

Remove the useless default test (aVeryImportantThingToTest) and create a test that try to create a new user and retrieve it:

bc. @Test
public void createAndRetrieveUser() {
    // Create a new user and save it
    new User("bob@gmail.com", "secret", "Bob").save();
    
    // Retrieve the user with bob username
    User bob = User.find("byEmail", "bob@gmail.com").first();
    
    // Test 
    assertNotNull(bob);
    assertEquals("Bob", bob.fullname);
}

As you see, the Model superclass give us two first very usefull methods : **save()** and **find()**. Select the **BasicTests.java** in the test runner, click start and check that all is green. 

We will need a method on the User class that check if a user with specified username and password exists. Let's write it and test it.

In the **User.java** source add the **connect()** method : 

bc. public static User connect(String email, String password) {
    return find("byEmailAndPassword", email, password).first();
}

And now the test case :

bc. @Test
public void tryConnectAsUser() {
    // Create a new user and save it
    new User("bob@gmail.com", "secret", "Bob").save();
    
    // Test 
    assertNotNull(User.connect("bob@gmail.com", "secret"));
    assertNull(User.connect("bob@gmail.com", "badpassword"));
    assertNull(User.connect("tom@gmail.com", "secret"));
}

Each time you make a modification you can run all the tests from the play test runner to check you don't have broken anything. 

h2. <a>The Post class</a>

The Post class will represent blog posts. Let's write a first implementation :

bc. package models;
 
import java.util.*;
import javax.persistence.*;
 
import play.db.jpa.*;
 
@Entity
public class Post extends Model {
 
    public String title;
    public Date postedAt;
    
    @Lob
    public String content;
    
    @ManyToOne
    public User author;
    
    public Post(User author, String title, String content) {
        this.author = author;
        this.title = title;
        this.content = content;
        this.postedAt = new Date();
    }
 
}

Here we use the **@Lob** annotation to tell JPA that we wat that it use a large text database type to store the post content. We have declared the relation to the User class using **@ManyToOne**. That means that each Post is authored by a single User and that each User can author several Posts.

We will write a new test case to check that to Post class works as expected. By before to write more tests we need to do something in the JUnit class. In the current test, the database content is never deleted, and each new run create more an more objects. It will become problematic soon because more advanced test will start to count objects to check that all is going file.

So let's write a JUnit **setup()** method to delete the database before each test :

bc. public class BasicTest extends UnitTest {
 
    @Before
    public void setup() {
        Fixtures.deleteAll();
    }
    
    ...
 
}

As you see, the Fixtures class is an helper that help you to deal with your database data during tests. Run the test again to check that you don't have broken anything, and start to write the next test :

bc. @Test
public void createPost() {
    // Create a new user and save it
    User bob = new User("bob@gmail.com", "secret", "Bob").save();
    
    // Create a new post
    new Post(bob, "My first post", "Hello world").save();
    
    // Test that the post has been created
    assertEquals(1, Post.count());
    
    // Retrieve all post created by bob
    List<Post> bobPosts = Post.find("byAuthor", bob).fetch();
    
    // Tests
    assertEquals(1, bobPosts.size());
    Post firstPost = bobPosts.get(0);
    assertNotNull(firstPost);
    assertEquals(bob, firstPost.author);
    assertEquals("My first post", firstPost.title);
    assertEquals("Hello world", firstPost.content);
    assertNotNull(firstPost.postedAt);
}

p(note). **Don't forget** to import the **java.util.List** or will get a compilation error.

h2. <a>Finish with Comment</a>

The last thing that we want to add at this first model draft is the ability to attach Comment to Posts. 

The creation of the Comment class is pretty straightforward.

bc. package models;
 
import java.util.*;
import javax.persistence.*;
 
import play.db.jpa.*;
 
@Entity
public class Comment extends Model {
 
    public String author;
    public Date postedAt;
     
    @Lob
    public String content;
    
    @ManyToOne
    public Post post;
    
    public Comment(Post post, String author, String content) {
        this.post = post;
        this.author = author;
        this.content = content;
        this.postedAt = new Date();
    }
 
}

Let's write a first test case :

bc. @Test
public void postComments() {
    // Create a new user and save it
    User bob = new User("bob@gmail.com", "secret", "Bob").save();
 
    // Create a new post
    Post bobPost = new Post(bob, "My first post", "Hello world").save();
 
    // Post a first comment
    new Comment(bobPost, "Jeff", "Nice post").save();
    new Comment(bobPost, "Tom", "I knew that !").save();
 
    // Retrieve all comments
    List<Comment> bobPostComments = Comment.find("byPost", bobPost).fetch();
 
    // Tests
    assertEquals(2, bobPostComments.size());
 
    Comment firstComment = bobPostComments.get(0);
    assertNotNull(firstComment);
    assertEquals("Jeff", firstComment.author);
    assertEquals("Nice post", firstComment.content);
    assertNotNull(firstComment.postedAt);
 
    Comment secondComment = bobPostComments.get(1);
    assertNotNull(secondComment);
    assertEquals("Tom", secondComment.author);
    assertEquals("I knew that !", secondComment.content);
    assertNotNull(secondComment.postedAt);
}

You see that the navigation between Post and Comments is not very easy because we need to use a query to retrieve all comments attached to Post. We can do better here by setting up the other side of the relation to the Post class. Add the comments field to the Post class :

bc. ...
@OneToMany(mappedBy="post", cascade=CascadeType.ALL)
public List<Comment> comments = new ArrayList();;
...

Note how we have used the mappedBy attribute to tell JPA that the Post class maintains the relation. When you define bi-directional relation with JPA it is very important to tell wich side will maintain the relation. In this case, because the Comments belong to the Post it is better that the Comment class maintains the relation. 

We have setted the casacade property to tell JPA that we want that the Post deletion be cascaded to comments. This way, if you delete a post, all related comments will be deleted too.

With this new relation, we will add an helper method to the Post class to simplify adding comments:

bc. public Post addComment(String author, String content) {
    Comment newComment = new Comment(this, author, content).save();
    this.comments.add(newComment);
    return this;
}

Let's write another test case to check that stuff :

bc. @Test
public void useTheCommentsRelation() {
    // Create a new user and save it
    User bob = new User("bob@gmail.com", "secret", "Bob").save();
 
    // Create a new post
    Post bobPost = new Post(bob, "My first post", "Hello world").save();
 
    // Post a first comment
    bobPost.addComment("Jeff", "Nice post");
    bobPost.addComment("Tom", "I knew that !");
 
    // Count things
    assertEquals(1, User.count());
    assertEquals(1, Post.count());
    assertEquals(2, Comment.count());
 
    // Retrieve the bob post
    bobPost = Post.find("byAuthor", bob).first();
    assertNotNull(bobPost);
 
    // Navigate to comments
    assertEquals(2, bobPost.comments.size());
    assertEquals("Jeff", bobPost.comments.get(0).author);
    
    // Delete the post
    bobPost.delete();
    
    // Chech the all comments have been deleted
    assertEquals(1, User.count());
    assertEquals(0, Post.count());
    assertEquals(0, Comment.count());
}

Is it green ?

!images/guide2-2!

h2. <a>Using fixture to write more complicated test</a>

When you start to write more complicated test, you often need to have an existing set of data to test on. Fixtures allows to describe your model in a YAML file and load it at any time before a test.

Edit the **/yabe/test/data.yml** file and start to describe a User :

bc. 
User(bob):
    email: bob@gmail.com
    password: secret
    fullname: Bob
 
...
 

Well, because the data.yml file is a litle big, you can "download it here":files/data.yml.

Now we create create a test case, that load these data and run some assertions over it:

bc. @Test
public void fullTest() {
    Fixtures.load("data.yml");
 
    // Count things
    assertEquals(2, User.count());
    assertEquals(3, Post.count());
    assertEquals(3, Comment.count());
 
    // Try to connect as users
    assertNotNull(User.connect("bob@gmail.com", "secret"));
    assertNotNull(User.connect("jeff@gmail.com", "secret"));
    assertNull(User.connect("jeff@gmail.com", "badpassword"));
    assertNull(User.connect("tom@gmail.com", "secret"));
 
    // Find all bob posts
    List<Post> bobPosts = Post.find("author.email", "bob@gmail.com").fetch();
    assertEquals(2, bobPosts.size());
 
    // Find all comments related to bob posts
    List<Comment> bobComments = Comment.find("post.author.email", "bob@gmail.com").fetch();
    assertEquals(3, bobComments.size());
 
    // Find the most recent post
    Post frontPost = Post.find("order by postedAt desc").first();
    assertNotNull(frontPost);
    assertEquals("About the model layer", frontPost.title);
 
    // Check that this post has two comments
    assertEquals(2, frontPost.comments.size());
 
    // Post a new comment
    frontPost.addComment("Jim", "Hello guys");
    assertEquals(3, frontPost.comments.size());
    assertEquals(4, Comment.count());
}

h2. <a>Save your work</a>

Well, we have now finished an hudge part on the blog engine. With all this things created and tested, we can now start to develop the web application.

But before continuing, it's time to save our work using bazaar. Open a command line an type **bzr st** to see the modifications made since the latest commit:

bc. $ bzr st

As you see there are some new files not under version control. The **test-result** folder don't need to be versioned. So let's ignore it.

bc. $ bzr ignore test-result

And add other files to version control using **bzr add**.

bc. $ bzr add

You can now commit your project.

bc. $ bzr commit -m "The model layer is ready"

p(note). Go to the "next part":guide3. 
