h1. Setting up a captcha

Because anyone can post a comment to our blog engine, we should protect it a little to avoid automated spam. A simple way to protect a form from bit is to add a captcha image.

h2. <a>Generating the captcha image</a>

We'll start to see how we can easily generate a captcha image using play. Basically we will just use another action, except that it will return a binary stream instead of HTML responses that we have returned so far. 

As play is a **full-stack** web framework, we try to add built-in constructs for all web applications typical needs. And generating a captcha is one. We can use the **play.libs.Images** utility to simply generate a captcha image, and then write it to the HTTP response. 

As always, we will start with a simple implementation. Add the **captcha** action to the **Application** controller:

bc. public static void captcha() {
    Images.Captcha captcha = Images.captcha();
    renderBinary(captcha);
}

p(note). **Don't forget** to import the play.libs.*.

Now add a new route to the **/yabe/conf/routes** file:

bc. GET     /captcha                                Application.captcha

And try the **captcha** action by opening "http://localhost:9000/captcha":http://localhost:9000/captcha.

!images/guide5-1!

It should generate a random text for each refresh.

h2. <a>How to manage the state ?</a>

Well, it was easy. But the most complicated part comes now. To validate the captcha we need to save somewhere the random text written to the captcha image and then check it at the form submission time. 

Of course we could just put the text to the user session at the image generation time and then retrieve it later. But this solution has two drawbacks:

**First** the play session is stored as a cookie. It solve a lot of problems in terms of architecture but has a lot of implications. Data written to the session cookie are signed (so the user can't modify them) but not crypted. If we write the captcha code to the session any bot could easily resolve it by reading the session cookie.

**Then** remember than play is a **stateless** framework. We want to manage things in a pure stateless way. Typically, what happen if a user open simultaneously two differents blog page with two differents captcha images ? We have to track the captcha code for each form.

So to resolve the problem we need two things. We will store the captcha secreet key on the server side. Because it is a transient data we can easily use the play **Cache**. Moreover because cached data have a limited life time it will add one more security mechanism (let's say that a captcha code will be available for only 10mn). Then to resolve the code later we need to generate a **unique ID**. This unique ID will be added to each form as an hidden field and implicitely references a generated captcha code.

This way we solve elegantly our state problem.

Modify the **captcha** action as is:

bc. public static void captcha(String id) {
    Images.Captcha captcha = Images.captcha();
    String code = captcha.getText("#E4EAFD");
    Cache.set(id, code, "10mn");
    renderBinary(captcha);
}

p(note). **Don't forget** to import the play.cache.*.

h2. <a>Adding the captcha image to the comment form</a>

Now, before to display a comment form we will generate a unique ID. Then we will modify the HTML form to integrate a captcha image using this ID, and add the ID to another hidden field.

Let's rewrite the **Application.show** action:

bc. public static void show(Long id) {
    Post post = Post.findById(id);
    String randomID = Codec.UUID();
    render(post, randomID);
}

And now the form in the **/yable/app/views/Application/show.html** template:

bc. ...
<p>
    <label for="content">Your message: </label>
    <textarea name="content" id="content">${params.content}</textarea>
</p>
<p>
    <label for="code">Please type the code below: </label>
    <img src="@{Application.captcha(randomID)}" />
    <br />
    <input type="text" name="code" id="code" size="18" value="" />
    <input type="hidden" name="randomID" value="${randomID}" />
</p>
<p>
    <input type="submit" value="Submit your comment" />
</p>
...

Good start. The comment form has now a captcha image.

!images/guide5-2!

h2. <a>Validating the captcha</a>

Now we just have to validate the captcha. We have added the **randomID** as an hidden field right ? So we can retrieve it in the **postComment** action, then retrieve the actual code from Cache and finally compare it to the submitted code.

Not so difficult. Let's modify the **postComment** action.

bc. public static void postComment(
        Long postId, 
        @Required(message="Author is required") String author, 
        @Required(message="A message is required") String content, 
        @Required(message="Please type the code") String code, 
        String randomID) 
{
    Post post = Post.findById(postId);
    validation.equals(
        code, Cache.get(randomID)
    ).message("Invalid code. Please type it again");
    if(validation.hasErrors()) {
        render("Application/show.html", post, randomID);
    }
    post.addComment(author, content);
    flash.success("Thanks for posting %s", author);
    show(postId);
}

Well because we have now more error messages, modify the way we display error in the **show.html** template:

bc. .. 
#{ifErrors}
    <p class="error">
        ${errors[0]}
    </p>
#{/ifErrors}
...

p(note). Typically for more complex form, error messages are not managed this way but externalized in the **messages** file. We'll see that later.

Check that the captcha is now fully functional.

!images/guide5-3!

p(note). Go to the "next part":guide6. 