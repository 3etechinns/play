h1. JPA Support

Play provides a set of very useful helpers to simplify the management of your JPA entities. 

p(note). **Note** that you can still go back to the plain JPA API when you want.

h2. <a>Starting the JPA entity manager</a>

Play will automatically start the Hibernate entity manager when it find one or more classes annotated with the **@javax.persistence.Entity** annotation. However, be sure that you already have correctly configured a JDBC datasource or it will fail.

h2. <a>Obtening the JPA entity manager</a>

When the JPA entity manager has been started you can retrieve it from the application code, using the JPA helper. For example:

bc. public static index() {
    Query query = JPA.em().createQuery("select * from Article");
    List<Article> articles = query.getResultList();
    render(articles);
}

h2. <a>Transaction management</a>

Play will automatically manage transaction for you. It will just start a transaction for each HTTP request and commit it when the HTTP response is sent. If your code throw an exception, the transaction will be automatically rollbacked.

If you need to force the rollback of the transaction from the application code, you can use the **JPA.setRollbackOnly()** method.

h2. <a>The **play.db.jpa.Model** support class</a>

This is the main helper class for JPA. If you make one of your JPA entity extends the **play.db.jpa.Model** class, it will give you a bunch of helper methods to simplify the JPA access.

For example, look at this Post model object:

bc. @Entity
public class Post extends Model {
    
    public String title;
    public String content;
    public Date postDate;
    
    @ManyToOne
    public Author author;
    
    @OneToMany
    public List<Comment> comments;
    
}

The **play.db.jpa.Model** class automatically provide a **autogenerated Long id** field. We think that it is generally a good idea to keep an autogenerated Long id as primary key for JPA models (the technical primary key) and manage your functional primary using another field.

Note that we have used that fact that play automatically consider **public** members of the Post class as **properties**. So we don't need to write all setter/getter methods for this object.

h2. <a>Finding objects</a>

The **play.db.jpa.Model** give you several ways to find data. For example:

h3. Find by ID

The simplest way to find an object.

bc. Post aPost = Post.findById(5L);

h3. Find all

bc. List<Post> posts = Post.findAll();

This is the simplest way to retrieve **all** posts, but you can do the same using:

bc. List<Post> posts = Post.all().fetch();

That allow you to paginate results:

bc. List<Post> posts = Post.all().fetch(100); // 100 max posts

or even,

bc. List<Post> posts = Post.all().from(50).fetch(100); // 100 max posts start at 50

h3. Find by a simplified query

That allow you to create very expressive finder, but will only work for pretty simple query.

bc. Post.find("byTitle", "My first post").fetch();
Post.find("byTitleLike", "%hello%").fetch();
Post.find("byAuthorIsNull").fetch();
Post.find("byTitleLikeAndAuthor", "%hello%", connectedUser).fetch();

h3. Find by a JPQL query

You can use a JPQL query:

bc. Post.find(
    "select p from Post p, Comment c where c.post = p and c.subject like ?", "%hop%"
);

or even a part of:

bc. Post.find("title", "My first post").fetch();
Post.find("title like ?", "%hello%").fetch();
Post.find("author is null").fetch();
Post.find("title like % and author is null", "%hello%").fetch();
Post.find("title like % and author is null order by postDate", "%hello%").fetch();

You can even specify only the **order by** statement:

bc. Post.find("order by postDate desc").fetch();

h2. <a>Counting objects</a>

You can easily count objects.

bc. long postCount = Post.count();

Or even count using a query:

bc. long userPostCount = Post.count("author = ?", connectedUser);

h2. <a>Explicit save</a>

Hibernate maintains a cache of Objects that have been queried from the database. These Objects are referred to as persistent Objects as long as the EntityManager that was used to fetch them is still active. What this means is that any changes to these Objects within the bounds of a transaction are automatically persisted when the transaction is committed. In standard JPA, these updates are implicit within the boundary of the transaction and you don’t have to explicitly call any method to persist the values.

The main downside is that we must manage all of our Objects by hand. Instead of telling the EntityManager to update an Object (which is far
more intuitive), we must tell the EntityManager which Objects NOT to update. We do this by calling refresh(), which essentially rolls back
a single entity. We do this just prior to calling commit on the transaction or when we realize the Object shouldn’t be updated.

Here is a common use case, when editing a persistent object after a form submit :

bc. public static void save(Long id) {
    User user = User.findById(id);
    user.edit(params);
    validation.valid(user);
    if(validation.hasErrors()) {
        // Here we have to explicitely discard the user modifications...
        user.refresh();
        edit(id);
    }
    show(id);
}

From what I've seen, most developers are not really aware of that, and forget to discard the object state in case of errors, assuming that the object will not be saved without an explicit call to save();

So, that exactly what we've changed in play. All the perstistent objects extending the JPASupport/JPAModel, will not be automactically saved without an explicit call to the save() method. So you can effectively rewrite the previous code as :

bc. public static void save(Long id) {
    User user = User.findById(id);
    user.edit(params);
    validation.valid(user);
    if(validation.hasErrors()) {
        edit(id);
    }
    user.save();
    show(id);
}

That is far more intuitive. Moreover because it could be tedious to call explicitely save() on a large object graph, the save() call is automatically cascade to the relations annotated with the **cascade=CascadeType.ALL** attribute.

h2. <a>More about generic typing problems</a>

The **play.db.jpa.Model** defines a set of generic methods. These generic methods use a type parameter to specify the return type of the method. When using those methods, the concrete type to be used as return value is derived from the invocation context using type inference.

For example, the **findAll** method is defined as:

bc. <T> List<T> findAll();

And you use it, as:

bc. List<Post> posts = Post.findAll();

Here the Java compiler resolve the actual type of **T** using the fact that you assign the method result to a ==List&lt;Post&gt;==. So T is resolved as Post type.

Unfortunately, this doesn't work, if the return value of the generic method isn't assigned to a variable, but rather is used as parameter for another method invocation or used in a loop. So the following code fails with a compiler error saying "Type mismatch: cannot convert from element type Object to Post":

bc. for(Post p : Post.findAll()) {
    p.delete();
}

Of course you can resolve this issue using a temporary local variable, as:

bc. List<Post> posts = Post.findAll(); // type inference works here !
for(Post p : posts) {
    p.delete();
}

But wait, there is a better way. You can use a practical but rather unknown feature of the Java language, which makes the code shorter while more readable at the same time:

bc. for(Post p : Post.<Post>findAll()) {
    p.delete();
}