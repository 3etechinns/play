#!/usr/bin/python
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Play! command line script www.playframework.org/

import sys
import os
import os.path
import shutil
import fileinput
import random
import re
import subprocess
import time


# Utilities

def replaceAll(file, searchExp, replaceExp):
	replaceExp = replaceExp.replace('\\', '\\\\')
	for line in fileinput.input(file, inplace=1):
		line = re.sub(searchExp, replaceExp, line)
		sys.stdout.write(line)

def secretKey():
	return ''.join([random.choice('abcdefghijklmnopqrstuvwxyz0123456789') for i in range(64)])

def readConf(key):
	for line in open(os.path.join(application_path, 'conf/application.conf')).readlines():
		if line.startswith('%' + play_id + '.' + key + "="):
			return line[line.find('=')+1:].strip()
		if line.startswith(key + "="):
			return line[line.find('=')+1:].strip()

def readConfs(key):
	result = []
	for line in open(os.path.join(application_path, 'conf/application.conf')).readlines():
		if line.startswith('%' + play_id + '.' + key):
			result.append(line[line.find('=')+1:].strip())
		if line.startswith(key):
			result.append(line[line.find('=')+1:].strip())
	return result

try:

	# ~~~~~~~~~~~~~~~~~~~~~~ Where is the framework ?
	play_base = os.path.normpath(os.path.dirname(os.path.abspath(sys.argv[0])))


	# ~~~~~~~~~~~~~~~~~~~~~~ What is the framework id ?
	id_file = os.path.join(play_base, 'id')
	if os.path.exists(id_file):
		play_id = open(id_file).readline().strip()
	else:
		play_id = ''


	# ~~~~~~~~~~~~~~~~~~~~~~ Display logo
	print r"~        _            _ "
	print r"~  _ __ | | __ _ _  _| |"
	print r"~ | '_ \| |/ _' | || |_|"
	print r"~ |  __/|_|\____|\__ (_)"
	print r"~ |_|            |__/   "
	print r"~"

	play_version_file = os.path.join(play_base, 'framework/src/play/version')
	if not os.path.exists(play_version_file):
		print "~ Oops. %s file not found" % os.path.normpath(os.path.join(play_base, 'framework/src/play/version'))
		print "~ Is the framework compiled ? "
		print "~"
		sys.exit(-1)

	print "~ play! %s, http://www.playframework.org" % (open(play_version_file).readline().strip())
	if play_id:
		print "~ framework ID is %s" % play_id
	print "~"


	# ~~~~~~~~~~~~~~~~~~~~~~ What is the command ?
	available_commands = ('help', 'id', 'new', 'clean', 'cp', 'pid', 'out', 'overrides', 'ov', 'modules', 'nb', 'netbeansify', 'ec', 'eclipsify', 'secret', 'run', 'test', 'debug', 'start', 'stop', 'restart')

	if len(sys.argv) < 2 or sys.argv[1] not in available_commands:
	  	print "~ Usage: play command [application path or current directory] "
	  	print "~ "
	  	print "~ with,  new      Create a new application"
	  	print "~        run      Run the application in the current window"
	  	print "~        debug    Run the application under JDPA debugger"
	  	print "~        test     Run all tests"
	  	print "~        help     Show more commands"
	  	print "~"
		if len(sys.argv) > 1 and sys.argv[1] not in available_commands:
			print "~ Invalid command : %s" % sys.argv[1]
			print "~"
		sys.exit(-1)

	play_command = sys.argv[1]


	# ~~~~~~~~~~~~~~~~~~~~~~ [help] Display help
	if play_command == 'help':
		print "~ Play commands : "
		print "~ "
		print "~        new          Create a new application"
		print "~        run          Run the application in the current window"
		print "~        start        Start the application in background"
		print "~        stop         Stop the application"
		print "~        restart      Restart the application in background"
		print "~        debug        Run the application under JDPA debugger"
		print "~        out          Output latest log messages"
		print "~        eclipsify    Create eclipse project (use ec as shortcut command)"
		print "~        netbeansify  Create netbeans project (use nb as shortcut command)"
		print "~        pid          Show the pid of an application"
		print "~        cp           Display the computed classpath"
		print "~        modules      Display the computed modules list"
		print "~        test         Run all tests"
		print "~        clean        Delete temporary files"
		print "~        id           Define the framework ID"
		print "~        secret       Generate a new secret key"
		print "~        override     Override a module file in the application"
		print "~        help         Show more commands"
		print "~ "
		print "~ Also refer to documentation at http://www.playframework.org/manual"
		print "~ "


	# ~~~~~~~~~~~~~~~~~~~~~~ [id] Define the framework ID
	if play_command == 'id':
		if not play_id:
			print "~ framework ID is not set"
		new_id = raw_input("~ What is the new framework ID (or blank to unset) ? ")
		if new_id:
			print "~"
			print "~ Ok, the framework ID is now %s" % new_id
			print "~"
			open(id_file, 'w').write(new_id)
		else:
			print "~"
			print "~ Ok, the framework ID is unset"
			print "~"
			if os.path.exists(id_file):
				os.remove(id_file)
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ Where is the application ?
	if len(sys.argv) == 2:
		application_path = os.getcwd()
		remaining_args = sys.argv[2:]
	else:
		application_path = os.path.normpath(os.path.abspath(sys.argv[2]))
		remaining_args = sys.argv[3:]
		
	if play_command == 'override' or play_command == 'ov':
		application_path = os.getcwd()


	# ~~~~~~~~~~~~~~~~~~~~~~ [new] Create a new application
	if play_command == 'new':
		if os.path.exists(application_path):
			print "~ Oops. %s already exists" % application_path
			print "~"
			sys.exit(-1)
		print "~ The new application will be created in %s" % os.path.normpath(application_path)
		application_name = raw_input("~ What is the application name ? ")
		shutil.copytree(os.path.join(play_base, 'resources/application-skel'), application_path)
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'%APPLICATION_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'%SECRET_KEY%', secretKey())
		print "~"
		print "~ Ok, the application is created."
		print "~ Start it with : play run %s" % sys.argv[2]
		print "~ Have fun !"
		print "~"
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ Check if it's a valid application
	if not os.path.exists(os.path.join(application_path, 'conf/routes')):
		print "~ Oops. %s does not seem to host a valid application" % os.path.normpath(application_path)
		print "~"
		sys.exit(-1)
	
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [secret] Generate a new secret key
	if play_command == 'secret':
		print "~ Generating secret key..."
		sk = secretKey()
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'application.secret=.*', 'application.secret=%s' % sk)
		print "~ Keep the secret : %s" % sk
		print "~"
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [clean] Clean temporary files
	if play_command == 'clean':
		print "~ Deleting %s" % os.path.normpath(os.path.join(application_path, 'tmp'))
		if os.path.exists(os.path.join(application_path, 'tmp')):
			shutil.rmtree(os.path.join(application_path, 'tmp'))
		print "~"
		sys.exit(0)
		
		
	# ~~~~~~~~~~~~~~~~~~~~~~ Modules list
	if os.environ.has_key('MODULES'):
		if os.name == 'nt':
			modules = os.environ['MODULES'].split(';')
		else:
			modules = os.environ['MODULES'].split(':')
	else:
		modules = []
		pm = readConfs('module.')
		for m in pm:
			if '${play.path}' in m:
				m = m.replace('${play.path}', play_base)
			if not m[0] == '/':
				m = os.path.normpath(os.path.join(application_path, m))
			modules.append(m)
		
		
	# ~~~~~~~~~~~~~~~~~~~~~~ [modules] Display the application modules
	if play_command == 'modules':
		if len(modules):
			print "~ Application modules are :"
			print "~ "
			for module in modules:
				print "~ %s" % module
		else:
			print "~ No modules"
		print "~ "
		sys.exit(0)	


	# ~~~~~~~~~~~~~~~~~~~~~~ [overrides] Overrides a module file
	if play_command == 'override' or play_command == 'ov':
		file = sys.argv[2]
		if file[0] == '/': file = file[1:]
		fromFile = None
		for module in modules:
			pc = os.path.join(module, file)
			if os.path.exists(pc): fromFile = pc
		if not fromFile:
			print "~ %s not found in any modules" % file
			print "~ "
			sys.exit(-1)
		if len(sys.argv) > 3:
			t = sys.argv[3]
			if t[0] == '/': t = t[1:]
			toFile = os.path.join(application_path, t)
		else:
			toFile = os.path.join(application_path, file)
		if os.path.exists(toFile):
			print "~ Warning ! %s already exists and will be overriden" % toFile
		response = raw_input("~ Copy %s to %s (y/n) ? " % (fromFile, toFile))
		if response == 'y':
			if not os.path.exists(os.path.dirname(toFile)):
				os.makedirs(os.path.dirname(toFile))
			shutil.copyfile(fromFile, toFile)
			print "~ "
			print "~ Ok"
			print "~"
			sys.exit(0)
		else:
			print "~ "
			print "~ Cancelled"
			print "~"
		sys.exit(0)	
	

	# ~~~~~~~~~~~~~~~~~~~~~~ JAVA_HOME/bin/java is used if defined
	if not os.environ.has_key('JAVA_HOME'):
		java_path = "java"
	else:
		java_path = "%s/bin/java" % os.environ['JAVA_HOME']


	# ~~~~~~~~~~~~~~~~~~~~~~ Read some configuration from conf/application.conf
	java_args=remaining_args

	memory_in_args=False
	for arg in java_args:
		if arg.startswith('Xm'):
			memory_in_args=True
	if not memory_in_args:
		memory = readConf('jvm.memory')
		if memory:
			java_args = java_args + memory.split(' ')

	jpda_port = readConf('jpda.port')
	if not jpda_port:
		jpda_port = '8000'

	application_mode = readConf('application.mode')

	if application_mode == 'prod':
		java_args.append('-server')

	java_args.append('-Dcom.sun.management.jmxremote')
	

	# ~~~~~~~~~~~~~~~~~~~~~~ Build classpath
	agent_path=os.path.join(play_base, 'framework/play.jar')
	
	classpath = []

	# The default
	classpath.append(os.path.normpath(os.path.join(application_path, 'conf')))
	classpath.append(os.path.normpath(os.path.join(play_base, 'framework/play.jar')))

	# The application
	for jar in os.listdir(os.path.join(application_path, 'lib')):
		if jar.endswith('.jar'):
			classpath.append(os.path.normpath(os.path.join(application_path, 'lib/%s' % jar)))
			
	# The modules
	for module in modules:
		libs = os.path.join(module, 'lib')
		if os.path.exists(libs):
			for jar in os.listdir(libs):
				if jar.endswith('.jar'):
					classpath.append(os.path.normpath(os.path.join(libs, '%s' % jar)))

	# The framework
	for jar in os.listdir(os.path.join(play_base, 'framework/lib')):
		if jar.endswith('.jar'):
			classpath.append(os.path.normpath(os.path.join(play_base, 'framework/lib/%s' % jar)))
			
		

	cp_args = ':'.join(classpath)
	if os.name == 'nt':
		cp_args = ';'.join(classpath)

	# ~~~~~~~~~~~~~~~~~~~~~~ [cp] Display the application classpath
	if play_command == 'cp':
		print "~ Computed classpath is :"
		print "~ "
		print cp_args
		print "~ "
		sys.exit(0)
	

	java_cmd = [java_path, '-javaagent:%s' % agent_path] + java_args + ['-classpath', cp_args, '-Dapplication.path=%s' % application_path, '-Dplay.id=%s' % play_id, 'play.server.Server']

	if not os.environ.has_key('PLAY_PID_PATH'):
		pid_path = os.path.join(application_path, 'server.pid');
	else:
		pid_path = os.environ['PLAY_PID_PATH'];
	
	if not os.environ.has_key('PLAY_LOG_PATH'):	
		log_path = os.path.join(application_path, 'logs');
	else:
		log_path = os.environ['PLAY_LOG_PATH'];
		
	if not os.path.exists(log_path):
		os.mkdir(log_path);
		
	# ~~~~~~~~~~~~~~~~~~~~~~ [run] Run the application
	if play_command == 'run':
		print "~ Ctrl+C to stop"
		print "~ "
		subprocess.call(java_cmd, env=os.environ)
		print
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [test] Run the application tests
	if play_command == 'test':
		print "~ Running application tests..."
		print "~ "
		java_cmd[-1] = 'play.test.TestRunner'
		subprocess.call(java_cmd, env=os.environ)
		print
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [debug] Debug the application
	if play_command == 'debug':
		print "~ Ctrl+C to stop"
		print "~ "
		java_cmd.insert(2, '-Xdebug')
		java_cmd.insert(2, '-Xrunjdwp:transport=dt_socket,address=%s,server=y,suspend=n' % jpda_port)
		java_cmd.insert(2, '-Dplay.debug=yes')
		subprocess.call(java_cmd, env=os.environ)
		print
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [start] Start the application
	if play_command == 'start':
		if os.path.exists(pid_path):
			print "~ Oops. %s is already started ! (or delete %s)" % (os.path.normpath(application_path), os.path.normpath(pid_path))
			print "~"
			sys.exit(1)
		sout = open(os.path.join(log_path, 'system.out'), 'w')
		pid = subprocess.Popen(java_cmd, stdout=sout, env=os.environ).pid
		print "~ Ok, %s is started" % os.path.normpath(application_path)
		print "~ output is redirected to %s" % os.path.normpath(os.path.join(log_path, 'system.out'))
		pid_file = open(pid_path, 'w')
		pid_file.write(str(pid))
		print "~ pid is %s" % pid
		print "~"
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [stop] Stop the application
	if play_command == 'stop':
		if not os.path.exists(pid_path):
			print "~ Oops! %s is not started (server.pid not found)" % os.path.normpath(application_path)
			print "~"
			sys.exit(-1)
		pid = open(pid_path).readline().strip()
		if os.name == 'nt':
			import ctypes
			handle = ctypes.windll.kernel32.OpenProcess(1, False, int(pid))
			if not ctypes.windll.kernel32.TerminateProcess(handle, 0):
				print "~ Cannot kill the process with pid %s (ERROR %s)" % (pid, ctypes.windll.kernel32.GetLastError())
				print "~ "
				sys.exit(-1)
		else:
			try:
				os.kill(int(pid), 15)
			except OSError:
				print "~ Play was not running (Process id %s not found)" % pid
				print "~ "
		
		os.remove(pid_path)
		print "~ Ok, %s is stopped" % application_path
		print "~"
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [restart] Restart the application
	if play_command == 'restart':
		if not os.path.exists(pid_path):
			print "~ Oops! %s is not started (server.pid not found)" % os.path.normpath(application_path)
			print "~"
			sys.exit(-1)
		pid = open(pid_path).readline().strip()
		if os.name == 'nt':
			import ctypes
			handle = ctypes.windll.kernel32.OpenProcess(1, False, int(pid))
			if not ctypes.windll.kernel32.TerminateProcess(handle, 0):
				print "~ Cannot kill the process with pid %s (%s)" % (pid, ctypes.windll.kernel32.GetLastError())
				print "~ "
				sys.exit(-1)
		else:
			try:
				os.kill(int(pid), 15)
			except OSError:
				print "~ Play was not running (Process id %s not found)" % pid
				print "~ "
		
		os.remove(pid_path)
		
		sout = open(os.path.join(log_path, 'system.out'), 'w')
		pid = subprocess.Popen(java_cmd, stdout=sout, env=os.environ).pid
		print "~ Ok, %s is restarted" % os.path.normpath(application_path)
		print "~ output is redirected to %s" % os.path.normpath(os.path.join(log_path, 'system.out'))
		pid_file = open(pid_path, 'w')
		pid_file.write(str(pid))
		print "~ New pid is %s" % pid
		print "~"
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [pid] Display the pid of the running application
	if play_command == 'pid':
		if not os.path.exists(pid_path):
			print "~ Oops! %s is not started (server.pid not found)" % os.path.normpath(application_path)
			print "~"
			sys.exit(-1)
		pid = open(pid_path).readline().strip()
		print "~ PID of the running applications is %s" % pid
		print "~ "
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [out] Follow logs of the running application
	if play_command == 'out':
		if not os.path.exists(pid_path):
			print "~ Oops! %s is not started (server.pid not found)" % os.path.normpath(application_path)
			print "~"
			sys.exit(-1)
		sout = open(os.path.join(log_path, 'system.out'), 'w')
		while True:
			where = sout.tell()
			line = sout.readline().strip()
			if not line:
				time.sleep(1)
				sout.seek(where)
			else:
				print line


	# ~~~~~~~~~~~~~~~~~~~~~~ [netbeansify] Create netbeans configuration files
	if play_command == 'nb' or play_command == 'netbeansify':
		application_name = readConf('application.name')
		if not application_name:
			application_name = os.path.dirname(application_path)
		nbproject = os.path.join(application_path, 'nbproject')
		if os.path.exists(nbproject):
			shutil.rmtree(nbproject)
			if os.name == 'nt':
				time.sleep(1)
		shutil.copytree(os.path.join(play_base, 'resources/nbproject'), nbproject)
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%APPLICATION_NAME%', application_name)
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%ANT_SCRIPT%', os.path.normpath(os.path.join(play_base, 'framework/build.xml')))
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%APPLICATION_PATH%', os.path.normpath(application_path))
		if os.name == 'nt':
			replaceAll(os.path.join(nbproject, 'project.xml'), r'%PLAY_CLASSPATH%', ';'.join(classpath + ['nbproject\\classes']))
		else:
			replaceAll(os.path.join(nbproject, 'project.xml'), r'%PLAY_CLASSPATH%', ':'.join(classpath + ['nbproject/classes']))
		mr = ""
		for module in modules:
			mr += "<package-root>%s</package-root>" % os.path.normpath(os.path.join(module, 'app'))
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%MODULES%', mr)
		mr = ""
		for dir in os.listdir(application_path):
			if os.path.isdir(os.path.join(application_path, dir)) and dir not in ['app', 'conf', 'test', 'public', 'tmp', 'logs', 'nbproject', 'lib']:
				mr = '<source-folder style="tree"><label>%s</label><location>%s</location></source-folder>' % (dir, dir)
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%MORE%', mr)
		print "~ Ok, the application is ready for netbeans"
		print "~ Just open %s as a netbeans project" % os.path.normpath(application_path)
		print "~"
		print "~ Use netbeansify again when you want to update netbeans configuration files, then close and open you project again."
		print "~"
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [eclipsify] Create eclipse configuration files
	if play_command == 'ec' or play_command == 'eclipsify':
		application_name = readConf('application.name')
		if not application_name:
			application_name = os.path.dirname(application_path)
		dotProject = os.path.join(application_path, '.project')
		dotClasspath = os.path.join(application_path, '.classpath')
		dotSettings = os.path.join(application_path, '.settings')
		eclipse = os.path.join(application_path, 'eclipse')
		if os.path.exists(eclipse):
			shutil.rmtree(eclipse)
			if os.name == 'nt':
				time.sleep(1)
				
		if os.path.exists(dotSettings):
			shutil.rmtree(dotSettings)
			if os.name == 'nt':
				time.sleep(1)
				
		shutil.copyfile(os.path.join(play_base, 'resources/eclipse/.project'), dotProject)
		shutil.copyfile(os.path.join(play_base, 'resources/eclipse/.classpath'), dotClasspath)
		shutil.copytree(os.path.join(play_base, 'resources/eclipse'), eclipse)
		shutil.copytree(os.path.join(play_base, 'resources/eclipse/.settings'), dotSettings)
		replaceAll(dotProject, r'%PROJECT_NAME%', application_name)
		
		cpXML = ""
		for el in classpath:
			cpXML += '<classpathentry kind="lib" path="%s" />' % os.path.normpath(el)
		replaceAll(dotClasspath, r'%PROJECTCLASSPATH%', cpXML)
		
		if len(modules):
			lXML = ""
			cXML = ""
			for module in modules:
				lXML += '<link><name>%s</name><type>2</type><location>%s</location></link>' % (os.path.basename(module), os.path.join(module, 'app'))
				cXML += '<classpathentry kind="src" path="%s"/>' % (os.path.basename(module))
			replaceAll(dotProject, r'%LINKS%', '<linkedResources>%s</linkedResources>' % lXML)
			replaceAll(dotClasspath, r'%MODULES%', cXML)
		else:
			replaceAll(dotProject, r'%LINKS%', '')
			replaceAll(dotClasspath, r'%MODULES%', '')
		
		replaceAll(os.path.join(application_path, 'eclipse/play.launch'), r'%PROJECT_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'eclipse/play.launch'), r'%PLAY_BASE%', play_base)
		replaceAll(os.path.join(application_path, 'eclipse/play.launch'), r'%PLAY_ID%', play_id)
		os.rename(os.path.join(application_path, 'eclipse/play.launch'), os.path.join(application_path, 'eclipse/%s.launch' % application_name))
		
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%PROJECT_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%PLAY_BASE%', play_base)
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%PLAY_ID%', play_id)
		os.rename(os.path.join(application_path, 'eclipse/test.launch'), os.path.join(application_path, 'eclipse/Test %s.launch' % application_name))	
		
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%PROJECT_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%PLAY_BASE%', play_base)
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%PLAY_ID%', play_id)
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%JPDA_PORT%', jpda_port)
		os.rename(os.path.join(application_path, 'eclipse/debug.launch'), os.path.join(application_path, 'eclipse/Debug %s.launch' % application_name))
		
		replaceAll(os.path.join(application_path, 'eclipse/connect.launch'), r'%PROJECT_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'eclipse/connect.launch'), r'%JPDA_PORT%', jpda_port)
		os.rename(os.path.join(application_path, 'eclipse/connect.launch'), os.path.join(application_path, 'eclipse/Connect JPDA to %s.launch' % application_name))
		
		print "~ Ok, the application is ready for eclipse"
		print "~ Use File/Import/General/Existing project to import %s into eclipse" % os.path.normpath(application_path)
		print "~"
		print "~ Use eclipsify again when you want to update eclipse configuration files."
		print "~ However, it's often better to delete and re-import the project into your workspace since eclipse keeps dirty caches ..."
		print "~"
				
		sys.exit(0)




except KeyboardInterrupt:
	print '~ ...'
	sys.exit(0)