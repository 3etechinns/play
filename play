#!/usr/bin/python
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Play! command line script www.playframework.org/

import sys
import os
import os.path
import shutil
import fileinput
import random
import re
import subprocess

# Utilities

def replaceAll(file, searchExp, replaceExp):
	for line in fileinput.input(file, inplace=1):
		line = re.sub(searchExp, replaceExp, line)
		sys.stdout.write(line)

def secretKey():
	return ''.join([random.choice('abcdefghijklmnopqrstuvwxyz0123456789') for i in range(64)])

def readConf(key):
	for line in open(os.path.join(application_path, 'conf/application.conf')).readlines():
		if line.startswith('%' + play_id + '.' + key + "="):
			return line[line.find('=')+1:].strip()
		if line.startswith(key + "="):
			return line[line.find('=')+1:].strip()

def readConfs(key):
	result = []
	for line in open(os.path.join(application_path, 'conf/application.conf')).readlines():
		if line.startswith('%' + play_id + '.' + key):
			result.append(line[line.find('=')+1:].strip())
		if line.startswith(key):
			result.append(line[line.find('=')+1:].strip())
	return result

try:

	# ~~~~~~~~~~~~~~~~~~~~~~ Where is the framework ?
	play_base = os.path.normpath(os.path.dirname(os.path.abspath(sys.argv[0])))


	# ~~~~~~~~~~~~~~~~~~~~~~ What is the framework id ?
	id_file = os.path.join(play_base, 'id')
	if os.path.exists(id_file):
		play_id = open(id_file).readline().strip()
	else:
		play_id = ''


	# ~~~~~~~~~~~~~~~~~~~~~~ Display logo
	print r"~        _            _ "
	print r"~  _ __ | | __ _ _  _| |"
	print r"~ | '_ \| |/ _' | || |_|"
	print r"~ |  __/|_|\____|\__ (_)"
	print r"~ |_|            |__/   "
	print r"~"

	play_version_file = os.path.join(play_base, 'framework/src/play/version')
	if not os.path.exists(play_version_file):
		print "~ Oops. %s/framework/src/play/version file not found" % play_base
		print "~ Is the framework compiled ? "
		print "~"
		sys.exit(-1)

	print "~ play! %s, http://www.playframework.org" % (open(play_version_file).readline().strip())
	if play_id:
		print "~ framework ID is %s" % play_id
	print "~"


	# ~~~~~~~~~~~~~~~~~~~~~~ What is the command ?
	available_commands = ('help', 'id', 'new', 'clean', 'cp', 'secret', 'run', 'test', 'debug', 'start', 'stop', 'restart')

	if len(sys.argv) < 2 or sys.argv[1] not in available_commands:
	  	print "~ Usage: play command [path or current directory] "
	  	print "~ "
	  	print "~ with,  new      Create a new application"
	  	print "~        run      Run the application in the current window"
	  	print "~        debug    Run the application under JDPA debugger"
	  	print "~        test     Run all tests"
	  	print "~        help     Show more commands"
	  	print "~"
		if len(sys.argv) > 1 and sys.argv[1] not in available_commands:
			print "~ Invalid command : %s" % sys.argv[1]
			print "~"
		sys.exit(-1)

	play_command = sys.argv[1]


	# ~~~~~~~~~~~~~~~~~~~~~~ [help] Display help
	if play_command == 'help':
		print "~ Play commands : "
		print "~ "
		print "~        new          Create a new application"
		print "~        run          Run the application in the current window"
		print "~        start        Start the application in background"
		print "~        stop         Stop the application"
		print "~        debug        Run the application under JDPA debugger"
		print "~        log          Output latest log messages"
		print "~        eclipsify    Create eclipse project"
		print "~        netbeansify  Create netbeans project"
		print "~        mkplugin     Create a Play! plugin with this application"
		print "~        pid          Show the pid of an application"
		print "~        clean        Delete temporary files"
		print "~        test         Run all tests"
		print "~        id           Define the framework ID"
		print "~        secret       Generate a new secret key"
		print "~        statistics   Display project statistics (soon)"
		print "~        help         To show more commands"
		print "~        help cmd     Show help for cmd"
		print "~ "
		print "~ Also refer to documentation at http://www.playframework.org/manual"
		print "~ "


	# ~~~~~~~~~~~~~~~~~~~~~~ [id] Define the framework ID
	if play_command == 'id':
		if not play_id:
			print "~ framework ID is not set"
		new_id = raw_input("~ What is the new framework ID (or blank to unset) ? ")
		if new_id:
			open(id_file, 'w').write(new_id)
		else:
			os.remove(id_file)
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ Where is the application ?
	if len(sys.argv) == 2:
		application_path = os.getcwd()
		remaining_args = sys.argv[2:]
	else:
		application_path = os.path.normpath(os.path.abspath(sys.argv[2]))
		remaining_args = sys.argv[3:]


	# ~~~~~~~~~~~~~~~~~~~~~~ [new] Create a new application
	if play_command == 'new':
		if os.path.exists(application_path):
			print "~ Oops. %s already exists" % application_path
			print "~"
			sys.exit(-1)
		print "~ The new application will be created in %s" % application_path
		application_name = raw_input("~ What is the application name ? ")
		shutil.copytree(os.path.join(play_base, 'resources/application-skel'), application_path)
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'%APPLICATION_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'%SECRET_KEY%', secretKey())
		print "~"
		print "~ Ok, the application is created."
		print "~ Start it with : play run %s" % sys.argv[2]
		print "~ Have fun !"
		print "~"
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ Check if it's a valid application
	if not os.path.exists(os.path.join(application_path, 'conf/routes')):
		print "~ Oops. %s does not seem to host a valid application" % application_path
		print "~"
		sys.exit(-1)
	
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [secret] Generate a new secret key
	if play_command == 'secret':
		print "~ Generating secret key..."
		sk = secretKey()
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'application.secret=.*', 'application.secret=%s' % sk)
		print "~ Keep the secret : %s" % sk
		print "~"
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [clean] Clean temporary files
	if play_command == 'clean':
		print "~ Deleting %s/tmp/*" % application_path
		if os.path.exists(os.path.join(application_path, 'tmp')):
			shutil.rmtree(os.path.join(application_path, 'tmp'))
		print "~"
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ JAVA_HOME/bin/java is used if defined
	if not os.environ.has_key('JAVA_HOME'):
		java_path = "java"
	else:
		java_path = "%s/bin/java" % os.environ['JAVA_HOME']


	# ~~~~~~~~~~~~~~~~~~~~~~ Read some configuration from conf/application.conf
	java_args=remaining_args

	memory_in_args=False
	for arg in java_args:
		if arg.startswith('Xm'):
			memory_in_args=True
	if not memory_in_args:
		memory = readConf('jvm.memory')
		if memory:
			java_args = java_args + memory.split(' ')

	jpda_port = readConf('jpda.port')
	if not jpda_port:
		jpda_port = '8000'

	application_mode = readConf('application.mode')

	if application_mode == 'prod':
		java_args.append('-server')

	java_args.append('-Dcom.sun.management.jmxremote')
	
	# ~~~~~~~~~~~~~~~~~~~~~~ Modules list
	if os.environ.has_key('MODULES'):
		if os.name == 'nt':
			modules = os.environ['MODULES'].split(';')
		else:
			modules = os.environ['MODULES'].split(':')
	else:
		modules = []
		pm = readConfs('module.')
		for m in pm:
			if '${play.path}' in m:
				m = m.replace('${play.path}', play_base)
			if not m[0] == '/':
				m = os.path.normpath(os.path.join(application_path, m))
			modules.append(m)


	# ~~~~~~~~~~~~~~~~~~~~~~ Build classpath
	agent_path=os.path.join(play_base, 'framework/play.jar')
	
	classpath = []

	# The default
	classpath.append(os.path.join(application_path, 'conf'))
	classpath.append(os.path.join(play_base, 'framework/play.jar'))

	# The application
	for jar in os.listdir(os.path.join(application_path, 'lib')):
		if jar.endswith('.jar'):
			classpath.append(os.path.join(application_path, 'lib/%s' % jar))
			
	# The modules
	for module in modules:
		libs = os.path.join(module, 'lib')
		if os.exists(libs):
			for jar in os.listdir(os.path.join(play_base, 'framework/lib')):
				

	# The framework
	for jar in os.listdir(os.path.join(play_base, 'framework/lib')):
		if jar.endswith('.jar'):
			classpath.append(os.path.join(play_base, 'framework/lib/%s' % jar))
			


	# ~~~~~~~~~~~~~~~~~~~~~~ [cp] Display the application classpath
	if play_command == 'cp':
		print "~ Computed classpath is"
		print"~ "
		print ':'.join(classpath)
		print "~ "
		sys.exit(0)

	cp_args = ':'.join(classpath)
	if os.name == 'nt':
		cp_args = ';'.join(classpath)
	java_cmd = [java_path, '-javaagent:%s' % agent_path] + java_args + ['-classpath', cp_args, '-Dapplication.path=%s' % application_path, '-Dplay.id=%s' % play_id, 'play.server.Server']


	# ~~~~~~~~~~~~~~~~~~~~~~ [run] Run the application
	if play_command == 'run':
		print "~ Ctrl+C to stop"
		print "~ "
		subprocess.call(java_cmd, env=os.environ)
		print
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [test] Run the application tests
	if play_command == 'test':
		print "~ Running application tests..."
		print "~ "
		java_cmd[-1] = 'play.test.TestRunner'
		subprocess.call(java_cmd, env=os.environ)
		print
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [debug] Debug the application
	if play_command == 'debug':
		print "~ Ctrl+C to stop"
		print "~ "
		java_cmd.insert(2, '-Xdebug')
		java_cmd.insert(2, '-Xrunjdwp:transport=dt_socket,address=%s,server=y,suspend=n' % jpda_port)
		java_cmd.insert(2, '-Dplay.debug=yes')
		subprocess.call(java_cmd, env=os.environ)
		print
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [start] Start the application
	if play_command == 'start':
		pid_path = os.path.join(application_path, 'server.pid')
		if os.path.exists(pid_path):
			print "~ Oops. %s is already started ! (or delete %s)" % (application_path, pid_path)
			print "~"
			sys.exit(1)
		if not os.path.exists(os.path.join(application_path, 'logs')):
			os.mkdir(os.path.join(application_path, 'logs'))
		sout = open(os.path.join(application_path, 'logs/system.out'), 'w')
		pid = subprocess.Popen(java_cmd, stdout=sout, env=os.environ).pid
		print "~ Ok, %s is started" % application_path
		print "~ output is redirected to %s/logs/system.out" % application_path
		pid_file = open(pid_path, 'w')
		pid_file.write(str(pid))
		print "~ pid is %s" % pid
		print "~"
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [stop] Stop the application
	if play_command == 'stop':
		pid_path = os.path.join(application_path, 'server.pid')
		if not os.path.exists(pid_path):
			print "~ Oops! %s is not started (server.pid not found)" % application_path
			print "~"
			sys.exit(-1)
		pid = open(pid_path).readline().strip()
		if os.name == 'nt':
			subprocess.Popen('TASKKILL /F /T /PID %s' % pid, shell=True)
		else:
			os.kill(int(pid), 15)
		os.remove(pid_path)
		print "~ Ok, %s is stopped" % application_path
		print "~"
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [restart] Restart the application
	if play_command == 'restart':
		pid_path = os.path.join(application_path, 'server.pid')
		if not os.path.exists(pid_path):
			print "~ Oops! %s is not started (server.pid not found)" % application_path
			print "~"
			sys.exit(-1)
		pid = open(pid_path).readline().strip()
		os.kill(int(pid), 15)
		os.remove(pid_path)
		if not os.path.exists(os.path.join(application_path, 'logs')):
			os.mkdir(os.path.join(application_path, 'logs'))
		sout = open(os.path.join(application_path, 'logs/system.out'), 'w')
		pid = subprocess.Popen(java_cmd, stdout=sout, env=os.environ).pid
		print "~ Ok, %s is restarted" % application_path
		print "~ output is redirected to %s/logs/system.out" % application_path
		pid_file = open(pid_path, 'w')
		pid_file.write(str(pid))
		print "~ New pid is %s" % pid
		print "~"
		sys.exit(0)


except KeyboardInterrupt:
	print '~ ...'
	sys.exit(0)