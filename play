#!/usr/bin/python
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Play command line script www.playframework.org/

import sys
import os
import os.path
import shutil
import fileinput
import random
import re
import subprocess
import time
import webbrowser
import urllib2
import socket
import getopt
import zipfile

# ~~~~~~~~~
# Utilities

toKill = None

def replaceAll(file, searchExp, replaceExp):
	replaceExp = replaceExp.replace('\\', '\\\\')
	searchExp = searchExp.replace('$', '\\$')
	searchExp = searchExp.replace('{', '\\{')
	searchExp = searchExp.replace('}', '\\}')
	for line in fileinput.input(file, inplace=1):
		line = re.sub(searchExp, replaceExp, line)
		sys.stdout.write(line)

def secretKey():
	return ''.join([random.choice('abcdefghijklmnopqrstuvwxyz0123456789') for i in range(64)])

def readConf(key):
	if application_path:
		keyRe = re.compile('^%' + play_id + '.' + key + '\s*=')
		for line in open(os.path.join(application_path, 'conf/application.conf')).readlines():
			if keyRe.match(line):
				return line[line.find('=')+1:].strip()
		keyRe = re.compile('^' + key + '\s*=')
		for line in open(os.path.join(application_path, 'conf/application.conf')).readlines():
			if keyRe.match(line):
				return line[line.find('=')+1:].strip()
	return ''

def readConfs(key):
	result = []
	if application_path:
		for line in open(os.path.join(application_path, 'conf/application.conf')).readlines():
			if line.startswith(key):
				result.append(line[line.find('=')+1:].strip())
		for line in open(os.path.join(application_path, 'conf/application.conf')).readlines():
			if line.startswith('%' + play_id + '.' + key):
				result.append(line[line.find('=')+1:].strip())
	return result

def kill(pid):
	if os.name == 'nt':
		import ctypes
		handle = ctypes.windll.kernel32.OpenProcess(1, False, int(pid))
		if not ctypes.windll.kernel32.TerminateProcess(handle, 0):
			print "~ Cannot kill the process with pid %s (ERROR %s)" % (pid, ctypes.windll.kernel32.GetLastError())
			print "~ "
			sys.exit(-1)
	else:
		try:
			os.kill(int(pid), 15)
		except OSError:
			print "~ Play was not running (Process id %s not found)" % pid
			print "~"
			sys.exit(-1)

def override(f, t):
	fromFile = None
	for module in modules:
		pc = os.path.join(module, f)
		if os.path.exists(pc): fromFile = pc
	if not fromFile:
		print "~ %s not found in any modules" % f
		print "~ "
		sys.exit(-1)
	toFile = os.path.join(application_path, t)
	if os.path.exists(toFile):
		response = raw_input("~ Warning! %s already exists and will be overriden (y/n)? " % toFile)
		if not response == 'y':
			return
	if not os.path.exists(os.path.dirname(toFile)):
		os.makedirs(os.path.dirname(toFile))
	shutil.copyfile(fromFile, toFile)
	print "~ Copied %s to %s " % (fromFile, toFile)

def isParentOf(path1, path2):
	if len(path2) < len(path1) or len(path2) < 2:
		return False
	if (path1 == path2):
		return True
	return isParentOf(path1, os.path.dirname(path2))

# ~~~~~~~~~
# Main

try:
	
	# ~~~~~~~~~~~~~~~~~~~~~~ Where is the framework?
	play_base = os.path.normpath(os.path.dirname(os.path.realpath(sys.argv[0])))

	
	# ~~~~~~~~~~~~~~~~~~~~~~ What is the framework id?
	id_file = os.path.join(play_base, 'id')
	if os.path.exists(id_file):
		play_id = open(id_file).readline().strip()
	else:
		play_id = ''

	
	# ~~~~~~~~~~~~~~~~~~~~~~ Display logo
	print r"~        _            _ "
	print r"~  _ __ | | __ _ _  _| |"
	print r"~ | '_ \| |/ _' | || |_|"
	print r"~ |  __/|_|\____|\__ (_)"
	print r"~ |_|            |__/   "
	print r"~"
	
	play_version_file = os.path.join(play_base, 'framework/src/play/version')
	if not os.path.exists(play_version_file):
		print "~ Oops. %s file not found" % os.path.normpath(os.path.join(play_base, 'framework/src/play/version'))
		print "~ Is the framework compiled? "
		print "~"
		sys.exit(-1)
	
	print "~ play! %s, http://www.playframework.org" % (open(play_version_file).readline().strip())
	
	# ~~~~~~~~~~~~~~~~~~~~~~ Where is the application?
	application_path = None
	remaining_args = []
	if len(sys.argv) == 2:
		application_path = os.getcwd()
		remaining_args = sys.argv[2:]
	if len(sys.argv) > 2:
		if sys.argv[2].startswith('-'):
			application_path = os.getcwd()
			remaining_args = sys.argv[2:]
		else:
			application_path = os.path.normpath(os.path.abspath(sys.argv[2]))
			remaining_args = sys.argv[3:]

	
	# ~~~~~~~~~~~~~~~~~~~~~~ What is the command?
	if len(sys.argv) > 1:
		play_command = sys.argv[1]
	else:
		play_command = 'none'
			
	
	# ~~~~~~~~~~~~~~~~~ Override id
	for a in remaining_args:
		if a.find('--%') == 0:
			play_id = a[3:]
	
	if play_command == 'test' or play_command == 'auto-test':
		play_id = 'test'

	
	if play_id:
		print "~ framework ID is %s" % play_id
	print "~"
	
	# ~~~~~~~~~~~~~~~~~~~~~~ Check if it's a valid application
	def check_application():
		global http_port
		if application_path and not os.path.exists(os.path.join(application_path, 'conf/routes')):
			print "~ Oops. %s does not seem to host a valid application" % os.path.normpath(application_path)
			print "~"
			sys.exit(-1)
		http_port = readConf('http.port')
		if not http_port:
			http_port = '9000'

	
	# ~~~~~~~~~~~~~~~~~~~~~~ Modules list
	def load_modules():
		global modules
		if os.environ.has_key('MODULES'):
			if os.name == 'nt':
				modules = os.environ['MODULES'].split(';')
			else:
				modules = os.environ['MODULES'].split(':')
		else:
			modules = []
		pm = readConfs('module.')
		for m in pm:
			om = m
			if '${play.path}' in m:
				m = m.replace('${play.path}', play_base)
			if not m[0] == '/':
				m = os.path.normpath(os.path.join(application_path, m))
			
			if not os.path.exists(m):
				print "~ Oops,"
				print "~ Module not found: %s" % (m)
				print "~"
				sys.exit(0)
			
			modules.append(m)
		if play_id == 'test':
			modules.append(os.path.normpath(os.path.join(play_base, 'modules/test-runner')))
		
	
	# ~~~~~~~~~~~~~~~~~~~~~~ Build classpath
	def do_classpath():
		global classpath
		global cp_args
		global agent_path
		
		agent_path=os.path.join(play_base, 'framework/play.jar')
		
		classpath = []
		
		# The default
		classpath.append(os.path.normpath(os.path.join(application_path, 'conf')))
		classpath.append(os.path.normpath(os.path.join(play_base, 'framework/play.jar')))
		
		# The application
		if os.path.exists(os.path.join(application_path, 'lib')):
		    for jar in os.listdir(os.path.join(application_path, 'lib')):
			    if jar.endswith('.jar'):
				    classpath.append(os.path.normpath(os.path.join(application_path, 'lib/%s' % jar)))
		
		# The modules
		for module in modules:
		    if os.path.exists(os.path.join(module, 'lib')):
			    libs = os.path.join(module, 'lib')
			    if os.path.exists(libs):
				    for jar in os.listdir(libs):
					    if jar.endswith('.jar'):
						    classpath.append(os.path.normpath(os.path.join(libs, '%s' % jar)))
		
		# The framework
		for jar in os.listdir(os.path.join(play_base, 'framework/lib')):
			if jar.endswith('.jar'):
				classpath.append(os.path.normpath(os.path.join(play_base, 'framework/lib/%s' % jar)))

		
		cp_args = ':'.join(classpath)
		if os.name == 'nt':
			cp_args = ';'.join(classpath)
	
	def check_jpda():
		global jpda_port
		try:
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.bind(('127.0.0.1', int(jpda_port)))
			s.close()
		except socket.error, e:
			print 'JPDA port %s is already used. Will try to use any free port for debugging' % jpda_port
			jpda_port = 0
	
	# ~~~~~~~~~~~~~~~~~~~~~~~ Build java path
	def do_java(className='play.server.Server'):
		global java_cmd
		global java_path
		global pid_path
		global application_mode
		global jpda_port
		global log_path
		
		# ~~~~~~~~~~~~~~~~~~~~~~ JAVA_HOME/bin/java is used if defined
		if not os.environ.has_key('JAVA_HOME'):
			java_path = "java"
		else:
			java_path = os.path.normpath("%s/bin/java" % os.environ['JAVA_HOME'])
		
		for a in remaining_args:
			if a.find('--with') == 0:
				remaining_args.remove(a)
			if a.find('--%') == 0:
				remaining_args.remove(a)
		# ~~~~~~~~~~~~~~~~~~~~~~ Read some configuration from conf/application.conf
		java_args = remaining_args[:]
		
		memory_in_args=False
		for arg in java_args:
			if arg.startswith('-Xm'):
				memory_in_args=True
		if not memory_in_args:
			memory = readConf('jvm.memory')
			if memory:
				java_args = java_args + memory.split(' ')
		
		jpda_port = readConf('jpda.port')
		if not jpda_port:
			jpda_port = '8000'
		
		application_mode = readConf('application.mode')
		
		if application_mode == 'prod':
			java_args.append('-server')
		
		java_policy = readConf('java.policy')
		if not java_policy == '':
			policyFile = os.path.join(application_path, 'conf', java_policy)
			if os.path.exists(policyFile):
				print "~ using policy file \"%s\"" % policyFile
				java_args.append('-Djava.security.manager')
				java_args.append('-Djava.security.policy==%s' % policyFile)
		
		# The Java stuff
		java_cmd = [java_path, '-javaagent:%s' % agent_path] + java_args + ['-classpath', cp_args, '-Dapplication.path=%s' % application_path, '-Dplay.id=%s' % play_id, className]
		
		if not os.environ.has_key('PLAY_PID_PATH'):
			pid_path = os.path.join(application_path, 'server.pid');
		else:
			pid_path = os.environ['PLAY_PID_PATH'];
		
		if not os.environ.has_key('PLAY_LOG_PATH'):
			log_path = os.path.join(application_path, 'logs');
		else:
			log_path = os.environ['PLAY_LOG_PATH'];
		
		if not os.path.exists(log_path):
			os.mkdir(log_path);

	
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# ~~~~~~~~~~~~~~~~~~~~~~ The commands ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [help] Display help
	if play_command == 'help':
		if len(sys.argv) == 3:
			cmd = sys.argv[2]
		else:
			cmd = 'all'
		help_file = os.path.join(play_base, 'documentation/commands/cmd-%s.txt' % cmd)
		if os.path.exists(help_file):
			print open(help_file, 'r').read()
			sys.exit(0)
		else:
			print '~ Oops, command \'%s\' not found. Try just \'play help\' to list all commands.' % cmd
			print '~'
			sys.exit(-1)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [id] Define the framework ID
	if play_command == 'id':
		if not play_id:
			print "~ framework ID is not set"
		new_id = raw_input("~ What is the new framework ID (or blank to unset)? ")
		if new_id:
			print "~"
			print "~ OK, the framework ID is now %s" % new_id
			print "~"
			open(id_file, 'w').write(new_id)
		else:
			print "~"
			print "~ OK, the framework ID is unset"
			print "~"
			if os.path.exists(id_file):
				os.remove(id_file)
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [new] Create a new application
	if play_command == 'new' or play_command == 'new,run':
		withModules = []
		application_name = None
		try:
			optlist, args = getopt.getopt(remaining_args, '', ['with=', 'name='])
			for o, a in optlist:
				if o in ('--with'):
					withModules = a.split(',')
				if o in ('--name'):
				    application_name = a
		except getopt.GetoptError, err:
			print "~ %s" % str(err)
			print "~ Sorry, unrecognized option"
			print "~ "
			sys.exit(-1)
		if os.path.exists(application_path):
			print "~ Oops. %s already exists" % application_path
			print "~"
			sys.exit(-1)
		print "~ The new application will be created in %s" % os.path.normpath(application_path)
		if application_name is None:
		    application_name = raw_input("~ What is the application name? ")
		shutil.copytree(os.path.join(play_base, 'resources/application-skel'), application_path)
		check_application()
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'%APPLICATION_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'%SECRET_KEY%', secretKey())
		for m in withModules:
			replaceAll(os.path.join(application_path, 'conf/application.conf'), r'#module.%s' % m, 'module.%s' % m)
		print "~"
		print "~ OK, the application is created."
		print "~ Start it with : play run %s" % sys.argv[2]
		print "~ Have fun!"
		print "~"
		if play_command == 'new': sys.exit(0)
	
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [secret] Generate a new secret key
	if play_command == 'secret':
		check_application()
		print "~ Generating the secret key..."
		sk = secretKey()
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'application.secret=.*', 'application.secret=%s' % sk)
		print "~ Keep the secret : %s" % sk
		print "~"
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [clean] Clean temporary files
	if play_command == 'clean' or play_command == 'clean,run':
		check_application()
		print "~ Deleting %s" % os.path.normpath(os.path.join(application_path, 'tmp'))
		if os.path.exists(os.path.join(application_path, 'tmp')):
			shutil.rmtree(os.path.join(application_path, 'tmp'))
		print "~"
		if play_command == 'clean': sys.exit(0)
		
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [modules] Display the application modules
	if play_command == 'modules':
		check_application()
		load_modules()
		if len(modules):
			print "~ Application modules are:"
			print "~ "
			for module in modules:
				print "~ %s" % module
		else:
			print "~ No modules"
		print "~ "
		sys.exit(0)
	
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [war] Generate a WAR
	if play_command == 'war':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		
		war_path = None
		war_zip_path = None
		try:
			optlist, args = getopt.getopt(remaining_args, 'o:', ['output=', 'zip'])
			for o, a in optlist:
				if o in ('-o', '--output'):
					war_path = os.path.normpath(os.path.abspath(a))
			for o, a in optlist:
				if o in ('--zip'):
					war_zip_path = war_path + '.war'
		except getopt.GetoptError, err:
			print "~ %s" % str(err)
			print "~ Please specify a path where to generate the WAR, using the -o or --output option"
			print "~ "
			sys.exit(-1)
		
		if not war_path:
			print "~ Oops. Please specify a path where to generate the WAR, using the -o or --output option"
			print "~"
			sys.exit(-1)
		
		if os.path.exists(war_path) and not os.path.exists(os.path.join(war_path, 'WEB-INF')):
			print "~ Oops. The destination path already exists but does not seem to host a valid WAR structure"
			print "~"
			sys.exit(-1)
			
		if isParentOf(application_path, war_path):
			print "~ Oops. Please specify a destination directory outside of the application"
			print "~"
			sys.exit(-1)
			
		print "~ Packaging current version of the framework and the application to %s ..." % (os.path.normpath(war_path))
		if os.path.exists(war_path): shutil.rmtree(war_path)
		if os.path.exists(os.path.join(application_path, 'war')):
			shutil.copytree(os.path.join(application_path, 'war'), war_path)
		else:
			os.mkdir(war_path)
		if not os.path.exists(os.path.join(war_path, 'WEB-INF')): os.mkdir(os.path.join(war_path, 'WEB-INF'))
		if not os.path.exists(os.path.join(war_path, 'WEB-INF/web.xml')):
		    shutil.copyfile(os.path.join(play_base, 'resources/war/web.xml'), os.path.join(war_path, 'WEB-INF/web.xml'))
		application_name = readConf('application.name')
		replaceAll(os.path.join(war_path, 'WEB-INF/web.xml'), r'%APPLICATION_NAME%', application_name)
		replaceAll(os.path.join(war_path, 'WEB-INF/web.xml'), r'%PLAY_ID%', play_id)
		if os.path.exists(os.path.join(war_path, 'WEB-INF/application')): shutil.rmtree(os.path.join(war_path, 'WEB-INF/application'))
		shutil.copytree(application_path, os.path.join(war_path, 'WEB-INF/application'))
		if os.path.exists(os.path.join(war_path, 'WEB-INF/application/war')):
			shutil.rmtree(os.path.join(war_path, 'WEB-INF/application/war'))
		if os.path.exists(os.path.join(war_path, 'WEB-INF/application/logs')):
			shutil.rmtree(os.path.join(war_path, 'WEB-INF/application/logs'))
		shutil.copytree(os.path.join(application_path, 'conf'), os.path.join(war_path, 'WEB-INF/classes'))
		if os.path.exists(os.path.join(war_path, 'WEB-INF/lib')): shutil.rmtree(os.path.join(war_path, 'WEB-INF/lib'))
		os.mkdir(os.path.join(war_path, 'WEB-INF/lib'))
		for jar in classpath:
			if jar.endswith('.jar') and jar.find('provided-') == -1:
				shutil.copyfile(jar, os.path.join(war_path, 'WEB-INF/lib/%s' % os.path.split(jar)[1]))
		if os.path.exists(os.path.join(war_path, 'WEB-INF/framework')): shutil.rmtree(os.path.join(war_path, 'WEB-INF/framework'))
		os.mkdir(os.path.join(war_path, 'WEB-INF/framework'))
		shutil.copytree(os.path.join(play_base, 'framework/templates'), os.path.join(war_path, 'WEB-INF/framework/templates'))
		
		# modules
		for module in modules:
			to = os.path.join(war_path, 'WEB-INF/modules/%s' % os.path.basename(module))
			shutil.copytree(module, to)
			if os.path.exists(os.path.join(to, 'src')):
				shutil.rmtree(os.path.join(to, 'src'))
			if os.path.exists(os.path.join(to, 'build.xml')):
				os.remove(os.path.join(to, 'build.xml'))
		pm = readConfs('module.')
		for m in pm:
			nm = os.path.basename(m)
			replaceAll(os.path.join(war_path, 'WEB-INF/application/conf/application.conf'), m, '../modules/%s' % nm)
		
		if not os.path.exists(os.path.join(war_path, 'WEB-INF/resources')): os.mkdir(os.path.join(war_path, 'WEB-INF/resources'))
		shutil.copyfile(os.path.join(play_base, 'resources/messages'), os.path.join(war_path, 'WEB-INF/resources/messages'))
		
		if war_zip_path:
			print "~ Creating zipped archive to %s ..." % (os.path.normpath(war_zip_path))
			if os.path.exists(war_zip_path):
				os.remove(war_zip_path)
			zip = zipfile.ZipFile(war_zip_path, 'w', zipfile.ZIP_STORED)
			dist_dir = os.path.join(application_path, 'dist')
			for (dirpath, dirnames, filenames) in os.walk(war_path):
				if dirpath == dist_dir:
					continue
				if dirpath.find('/.') > -1:
					continue
				for file in filenames:
					if file.find('~') > -1 or file.startswith('.'):
						continue
					zip.write(os.path.join(dirpath, file), os.path.join(dirpath[len(war_path):], file))

			zip.close()
		print "~ Done !"
		print "~"
		print "~ You can now load %s as a standard WAR into your servlet container" % (os.path.normpath(war_path))
		print "~ You can't use play standard commands to run/stop/debug the WAR application..."
		print "~ ... just use your servlet container commands instead"
		print "~"
		print "~ Have fun!"
		print "~"
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [cp] Display the application classpath
	if play_command == 'cp' or play_command == 'classpath':
		check_application()
		load_modules()
		do_classpath()
		print "~ Computed classpath is:"
		print "~ "
		print cp_args
		print "~ "
		sys.exit(0)
		
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [run] Run the application
	if play_command == 'run' or play_command == 'new,run' or play_command == 'clean,run':
		check_application()
		load_modules()
		do_classpath()
		disable_check_jpda = False
		if remaining_args.count('-f') == 1:
			disable_check_jpda = True
			remaining_args.remove('-f')
		do_java()
		print "~ Ctrl+C to stop"
		print "~ "
		if application_mode == 'dev':
			if not disable_check_jpda: check_jpda()
			java_cmd.insert(2, '-Xdebug')
			java_cmd.insert(2, '-Xrunjdwp:transport=dt_socket,address=%s,server=y,suspend=n' % jpda_port)
			java_cmd.insert(2, '-Dplay.debug=yes')
		try:
			subprocess.call(java_cmd, env=os.environ)
		except OSError:
			print "Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). "
			sys.exit(-1)
		print
		sys.exit(0)
	
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [status] Get application status
	if play_command == 'status' or play_command == 'st':
		url = ''
		secret_key = ''
		
		try:
			optlist, args = getopt.getopt(remaining_args, '', ['url=', 'secret='])
			for o, a in optlist:
				if o in ('--url'):
					if a.endswith('/'):
						url = a + '@status'
					else:
						url = a + '/@status'
				if o in ('--secret'):
					secret_key = a
		except getopt.GetoptError, err:
			print "~ %s" % str(err)
			print "~ "
			sys.exit(-1)
		
		if not url or not secret_key:
			check_application()
			if not url:
				http_port = readConf('http.port')
				if not http_port:
					http_port = 9000
				else:
					http_port = int(http_port)
				url = 'http://localhost:%s/@status' % http_port
			if not secret_key:
				secret_key = readConf('application.secret')
		
		import hmac
		from hashlib import sha1 as sha
		
		hm = hmac.new(secret_key, '@status', sha)
		authorization = hm.hexdigest()
		
		try:
			proxy_handler = urllib2.ProxyHandler({})
			req = urllib2.Request(url)
			req.add_header('Authorization', authorization)
			opener = urllib2.build_opener(proxy_handler)
			status = opener.open(req);
			print '~ Status from %s,' % url
			print '~'
			print status.read()
			print '~'
		except urllib2.HTTPError, e:
			print "~ Cannot retrieve the application status... (%s)" % (e.code)
			print "~"
			sys.exit(-1)
		except urllib2.URLError, e:
			print "~ Cannot contact the application..."
			print "~"
			sys.exit(-1)
		print
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [test] Run the application tests
	if play_command == 'test':
		check_application()
		load_modules()
		do_classpath()
		disable_check_jpda = False
		if remaining_args.count('-f') == 1:
			disable_check_jpda = True
			remaining_args.remove('-f')
		do_java()
		print "~ Running in test mode"
		print "~ Ctrl+C to stop"
		print "~ "
		check_jpda()
		java_cmd.insert(2, '-Xdebug')
		java_cmd.insert(2, '-Xrunjdwp:transport=dt_socket,address=%s,server=y,suspend=n' % jpda_port)
		java_cmd.insert(2, '-Dplay.debug=yes')
		try:
			subprocess.call(java_cmd, env=os.environ)
		except OSError:
			print "Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). "
			sys.exit(-1)
		print
		sys.exit(0)
		
	
	# ~~~~~~~~~~~~~~~~~~~~~~ [auto-test] Run the application tests
	if play_command == 'auto-test':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		print "~ Running in test mode"
		print "~ Ctrl+C to stop"
		print "~ "
		test_result = os.path.join(application_path, 'test-result')
		if os.path.exists(test_result):
			shutil.rmtree(test_result)
		sout = open(os.path.join(log_path, 'system.out'), 'w')
		try:
			play_process = subprocess.Popen(java_cmd, env=os.environ, stdout=sout)
		except OSError:
			print "Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). "
			sys.exit(-1)
		soutint = open(os.path.join(log_path, 'system.out'), 'r')
		while True:
			if play_process.poll():
 				print "~"
				print "~ Oops, application has not started?"
				print "~"
				sys.exit(-1)
			line = soutint.readline().strip()
			if line:
				print line
				if line.find('Listening for HTTP') > -1:
					soutint.close()
					break
		# Launch the browser
		print "~"
		print "~ Loading the test runner at %s ..." % ('http://localhost:%s/@tests' % http_port)
		try:
			proxy_handler = urllib2.ProxyHandler({})
			opener = urllib2.build_opener(proxy_handler)
			opener.open('http://localhost:%s/@tests' % http_port);
		except urllib2.HTTPError, e:
			print "~"
			print "~ There are compilation errors... (%s)" % (e.code)
			print "~"
			kill(play_process.pid)
			sys.exit(-1)
		print "~ Launching a web browser at http://localhost:%s/@tests?select=all&auto=yes ..." % http_port
		webbrowser.open('http://localhost:%s/@tests?select=all&auto=yes' % http_port)
		while True:
			time.sleep(1)
			if os.path.exists(os.path.join(application_path, 'test-result/result.passed')):
				print "~"
				print "~ All tests passed"
				print "~"
				kill(play_process.pid)
				break
			if os.path.exists(os.path.join(application_path, 'test-result/result.failed')):
				print "~"
				print "~ Some tests have failed. See file://%s for results" % test_result
				print "~"
				kill(play_process.pid)
				break
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [precompile] Precompile
	if play_command == 'precompile':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if os.path.exists(os.path.join(application_path, 'tmp')):
			shutil.rmtree(os.path.join(application_path, 'tmp'))
		java_cmd.insert(2, '-Dprecompile=yes')
		try:
			subprocess.call(java_cmd, env=os.environ)
		except OSError:
			print "Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). "
			sys.exit(-1)
		print
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [start] Start the application
	if play_command == 'start':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if os.path.exists(pid_path):
			print "~ Oops. %s is already started! (or delete %s)" % (os.path.normpath(application_path), os.path.normpath(pid_path))
			print "~"
			sys.exit(1)
		
		sysout = readConf('application.log.system.out')
		sysout = sysout!='false' and sysout!='off'
		if not sysout:
		  sout = None
		else:
		  sout = open(os.path.join(log_path, 'system.out'), 'w')
		try:
			pid = subprocess.Popen(java_cmd, stdout=sout, env=os.environ).pid
		except OSError:
			print "Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). "
			sys.exit(-1)
		print "~ OK, %s is started" % os.path.normpath(application_path)
		if sysout:
		  print "~ output is redirected to %s" % os.path.normpath(os.path.join(log_path, 'system.out'))
		pid_file = open(pid_path, 'w')
		pid_file.write(str(pid))
		print "~ pid is %s" % pid
		print "~"
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [stop] Stop the application
	if play_command == 'stop':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if not os.path.exists(pid_path):
			print "~ Oops! %s is not started (server.pid not found)" % os.path.normpath(application_path)
			print "~"
			sys.exit(-1)
		pid = open(pid_path).readline().strip()
		os.remove(pid_path)
		kill(pid)
		print "~ OK, %s is stopped" % application_path
		print "~"
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [restart] Restart the application
	if play_command == 'restart':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if not os.path.exists(pid_path):
			print "~ Oops! %s is not started (server.pid not found)" % os.path.normpath(application_path)
			print "~"
		else:
			pid = open(pid_path).readline().strip()
			os.remove(pid_path)
			kill(pid)

		
		sysout = readConf('application.log.system.out')
		sysout = sysout!='false' and sysout!='off'
		if not sysout:
		  sout = None
		else:
		  sout = open(os.path.join(log_path, 'system.out'), 'w')
		try:
			pid = subprocess.Popen(java_cmd, stdout=sout, env=os.environ).pid
		except OSError:
			print "Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). "
			sys.exit(-1)
		print "~ OK, %s is restarted" % os.path.normpath(application_path)
		if sysout:
		  print "~ output is redirected to %s" % os.path.normpath(os.path.join(log_path, 'system.out'))
		pid_file = open(pid_path, 'w')
		pid_file.write(str(pid))
		print "~ New pid is %s" % pid
		print "~"
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [pid] Display the pid of the running application
	if play_command == 'pid':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if not os.path.exists(pid_path):
			print "~ Oops! %s is not started (server.pid not found)" % os.path.normpath(application_path)
			print "~"
			sys.exit(-1)
		pid = open(pid_path).readline().strip()
		print "~ PID of the running applications is %s" % pid
		print "~ "
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [out] Follow logs of the running application
	if play_command == 'out':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if not os.path.exists(os.path.join(log_path, 'system.out')):
			print "~ Oops! %s not found" % os.path.normpath(os.path.join(log_path, 'system.out'))
			print "~"
			sys.exit(-1)
		sout = open(os.path.join(log_path, 'system.out'), 'r')
		try:
			sout.seek(-5000, os.SEEK_END)
		except IOError:
			sout.seek(0)
		while True:
			where = sout.tell()
			line = sout.readline().strip()
			if not line:
				time.sleep(1)
				sout.seek(where)
			else:
				print line

	# ~~~~~~~~~~~~~~~~~~~~~~ [javadoc] Generates the javadoc for the project
	if play_command == 'jd' or play_command == 'javadoc':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if not os.environ.has_key('JAVA_HOME'):
			javadoc_path = "javadoc"
		else:
			javadoc_path = os.path.normpath("%s/bin/javadoc" % os.environ['JAVA_HOME'])

		fileList = []
		def add_java_files(app_path):
			for root, subFolders, files in os.walk(os.path.join(app_path, 'app')):
				for file in files:
					if file.endswith(".java"):
						fileList.append(os.path.join(root, file))
		add_java_files(application_path)
		for module in modules:
			add_java_files(os.path.normpath(module))
		outdir = os.path.join(application_path, 'javadoc')
		sout = open(os.path.join(log_path, 'javadoc.log'), 'w')
		serr = open(os.path.join(log_path, 'javadoc.err'), 'w')
		if (os.path.isdir(outdir)):
			shutil.rmtree(outdir)
		javadoc_cmd = [javadoc_path, '-classpath', cp_args, '-d', outdir] + fileList
		print "Generating Javadoc in " + outdir + "..."
		subprocess.call(javadoc_cmd, env=os.environ, stdout=sout, stderr=serr)
		print "Done! You can open " + os.path.join(outdir, 'overview-tree.html') + " in your browser."
		sys.exit(0)

	# ~~~~~~~~~~~~~~~~~~~~~~ [netbeansify] Create netbeans configuration files
	if play_command == 'nb' or play_command == 'netbeansify':
		check_application()
		load_modules()
		do_classpath()
		application_name = readConf('application.name')
		if not application_name:
			application_name = os.path.dirname(application_path)
		nbproject = os.path.join(application_path, 'nbproject')
		if os.path.exists(nbproject):
			shutil.rmtree(nbproject)
			if os.name == 'nt':
				time.sleep(1)
		shutil.copytree(os.path.join(play_base, 'resources/_nbproject'), nbproject)
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%APPLICATION_NAME%', application_name)
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%ANT_SCRIPT%', os.path.normpath(os.path.join(play_base, 'framework/build.xml')))
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%APPLICATION_PATH%', os.path.normpath(application_path))
		if os.name == 'nt':
			replaceAll(os.path.join(nbproject, 'project.xml'), r'%PLAY_CLASSPATH%', ';'.join(classpath + ['nbproject\\classes']))
		else:
			replaceAll(os.path.join(nbproject, 'project.xml'), r'%PLAY_CLASSPATH%', ':'.join(classpath + ['nbproject/classes']))
		mr = ""
		for module in modules:
			mr += "<package-root>%s</package-root>" % os.path.normpath(os.path.join(module, 'app'))
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%MODULES%', mr)
		mr = ""
		for dir in os.listdir(application_path):
			if os.path.isdir(os.path.join(application_path, dir)) and dir not in ['app', 'conf', 'test', 'test-result', 'public', 'tmp', 'logs', 'nbproject', 'lib']:
				mr = '<source-folder style="tree"><label>%s</label><location>%s</location></source-folder>' % (dir, dir)
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%MORE%', mr)
		print "~ OK, the application is ready for netbeans"
		print "~ Just open %s as a netbeans project" % os.path.normpath(application_path)
		print "~"
		print "~ Use netbeansify again when you want to update netbeans configuration files, then close and open you project again."
		print "~"
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [eclipsify] Create eclipse configuration files
	if play_command == 'ec' or play_command == 'eclipsify':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		application_name = readConf('application.name')
		if not application_name:
			application_name = os.path.dirname(application_path)
		dotProject = os.path.join(application_path, '.project')
		dotClasspath = os.path.join(application_path, '.classpath')
		dotSettings = os.path.join(application_path, '.settings')
		eclipse = os.path.join(application_path, 'eclipse')
		if os.path.exists(eclipse):
			shutil.rmtree(eclipse)
			if os.name == 'nt':
				time.sleep(1)
		
		if os.path.exists(dotSettings):
			shutil.rmtree(dotSettings)
			if os.name == 'nt':
				time.sleep(1)
		
		shutil.copyfile(os.path.join(play_base, 'resources/eclipse/.project'), dotProject)
		shutil.copyfile(os.path.join(play_base, 'resources/eclipse/.classpath'), dotClasspath)
		shutil.copytree(os.path.join(play_base, 'resources/eclipse'), eclipse)
		shutil.copytree(os.path.join(play_base, 'resources/eclipse/.settings'), dotSettings)
		replaceAll(dotProject, r'%PROJECT_NAME%', application_name)
		
		playJarPath = os.path.join(play_base, 'framework','play.jar')
		playSourcePath = os.path.dirname(playJarPath)
		if os.name == 'nt':
			playSourcePath=playSourcePath.replace('\\','/').capitalize()
		
		cpXML = ""
		for el in classpath:
			if not os.path.basename(el) == "conf":
				if el == playJarPath:
					cpXML += '<classpathentry kind="lib" path="%s" sourcepath="%s" />\n\t' % (os.path.normpath(el) , playSourcePath)
				else:
					cpXML += '<classpathentry kind="lib" path="%s" />\n\t' % os.path.normpath(el)
		replaceAll(dotClasspath, r'%PROJECTCLASSPATH%', cpXML)
		
		if len(modules):
			lXML = ""
			cXML = ""
			for module in modules:
				lXML += '<link><name>%s</name><type>2</type><location>%s</location></link>\n' % (os.path.basename(module), os.path.join(module, 'app').replace('\\', '/'))
				if os.path.exists(os.path.join(module, "conf")):
					lXML += '<link><name>conf/%s</name><type>2</type><location>%s/conf</location></link>\n' % (os.path.basename(module), module.replace('\\', '/'))
				if os.path.exists(os.path.join(module, "public")):
					lXML += '<link><name>public/%s</name><type>2</type><location>%s/public</location></link>\n' % (os.path.basename(module), module.replace('\\', '/'))
				cXML += '<classpathentry kind="src" path="%s"/>' % (os.path.basename(module))
			replaceAll(dotProject, r'%LINKS%', '<linkedResources>%s</linkedResources>' % lXML)
			replaceAll(dotClasspath, r'%MODULES%', cXML)
		else:
			replaceAll(dotProject, r'%LINKS%', '')
			replaceAll(dotClasspath, r'%MODULES%', '')
		
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%PROJECT_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%PLAY_BASE%', play_base)
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%PLAY_ID%', play_id)
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%JPDA_PORT%', jpda_port)
		
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%PROJECT_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%PLAY_BASE%', play_base)
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%PLAY_ID%', play_id)
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%JPDA_PORT%', jpda_port)
		
		replaceAll(os.path.join(application_path, 'eclipse/connect.launch'), r'%PROJECT_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'eclipse/connect.launch'), r'%JPDA_PORT%', jpda_port)
		
		os.rename(os.path.join(application_path, 'eclipse/connect.launch'), os.path.join(application_path, 'eclipse/Connect JPDA to %s.launch' % application_name))
		os.rename(os.path.join(application_path, 'eclipse/test.launch'), os.path.join(application_path, 'eclipse/Test %s.launch' % application_name))
		os.rename(os.path.join(application_path, 'eclipse/debug.launch'), os.path.join(application_path, 'eclipse/%s.launch' % application_name))
		
		print "~ OK, the application is ready for eclipse"
		print "~ Use File/Import/General/Existing project to import %s into eclipse" % os.path.normpath(application_path)
		print "~"
		print "~ Use eclipsify again when you want to update eclipse configuration files."
		print "~ However, it's often better to delete and re-import the project into your workspace since eclipse keeps dirty caches..."
		print "~"
		
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [idealize] Create idea intellij configuration files
	if play_command == 'idea' or play_command == 'idealize':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		application_name = readConf('application.name')
		imlFile = os.path.join(application_path, application_name + '.iml')
		shutil.copyfile(os.path.join(play_base, 'resources/idea/imlTemplate.xml'), imlFile)
		cpXML = ""
		
		replaceAll(imlFile, r'%PLAYHOME%', play_base.replace('\\', '/'))
		
		if len(modules):
			lXML = ""
			cXML = ""
			for module in modules:
				lXML += '    <content url="file://%s">\n      <sourceFolder url="file://%s" isTestSource="false" />\n    </content>\n' % (module, os.path.join(module, 'app').replace('\\', '/'))
			replaceAll(imlFile, r'%LINKS%', lXML)
		else:
			replaceAll(imlFile, r'%LINKS%', '')
		
		print "~ OK, the application is ready for Intellij Idea"
		print "~ Use File/New Module/Import Existing module"
		print "~"
		
		sys.exit(0)

	
	
	# Module command ?
	if play_command.find(':') > 0:
		check_application()
		load_modules()
		for module in modules:
			commands = os.path.join(module, 'commands.py')
			if os.path.exists(commands):
				execfile(commands)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ Invalid command
	print "~ Usage: play cmd [app_path] [--options]"
	print "~ "
	print "~ with,  new      Create a new application"
	print "~        run      Run the application in the current shell"
	print "~        help     Show play help"
	print "~"
	if len(sys.argv) > 1:
		print "~ Invalid command: %s" % sys.argv[1]
		print "~"
	sys.exit(-1)


except KeyboardInterrupt:
	print '~ ...'
	sys.exit(0)


