#!/usr/bin/python
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Play command line script www.playframework.org/

import sys
import os
import os.path
import string
import shutil
import fileinput
import random
import re
import subprocess
import time
import webbrowser
import urllib
import urllib2
import socket
import getopt
import zipfile
import imp
import tempfile

import framework.pym.cmdloader as cmdloader
import framework.pym.java as javautils
from framework.pym.modules import Downloader, Unzip
from framework.pym.application import *
from framework.pym.utils import *

# ~~~~~~~~~
# Main

try:

	play_env = dict()

	# ~~~~~~~~~~~~~~~~~~~~~~ Where is the framework?
	play_env["basedir"] = os.path.normpath(os.path.dirname(os.path.realpath(sys.argv[0])))

	# ~~~~~~~~~~~~~~~~~~~~~~ What is the framework id?
	id_file = os.path.join(play_env['basedir'], 'id')
	if os.path.exists(id_file):
		play_env["id"] = open(id_file).readline().strip()
	else:
		play_env["id"] = ''

	# ~~~~~~~~~~~~~~~~~~~~~~ Display logo
	print r"~        _            _ "
	print r"~  _ __ | | __ _ _  _| |"
	print r"~ | '_ \| |/ _' | || |_|"
	print r"~ |  __/|_|\____|\__ (_)"
	print r"~ |_|            |__/   "
	print r"~"

	play_version_file = os.path.join(play_env["basedir"], 'framework/src/play/version')
	if not os.path.exists(play_version_file):
		print "~ Oops. %s file not found" % os.path.normpath(os.path.join(play_env["basedir"], 'framework/src/play/version'))
		print "~ Is the framework compiled? "
		print "~"
		sys.exit(-1)

	play_env["version"] = open(play_version_file).readline().strip()

	print "~ play! %s, http://www.playframework.org" % (play_env["version"])

	# ~~~~~~~~~~~~~~~~~~~~~~ Where is the application?
	application_path = None
	remaining_args = []
	if len(sys.argv) == 2:
		application_path = os.getcwd()
		remaining_args = sys.argv[2:]
	if len(sys.argv) > 2:
		if sys.argv[2].startswith('-'):
			application_path = os.getcwd()
			remaining_args = sys.argv[2:]
		else:
			application_path = os.path.normpath(os.path.abspath(sys.argv[2]))
			remaining_args = sys.argv[3:]

	play_app = PlayApplication(application_path, play_env)

	cmdloader.load_all(play_env["basedir"])

	# ~~~~~~~~~~~~~~~~~~~~~~ What is the command?
	if len(sys.argv) > 1:
		play_command = sys.argv[1]
	else:
		play_command = 'none'

	# ~~~~~~~~~~~~~~~~~ Override id
	for a in remaining_args:
		if a.find('--%') == 0:
			play_env["id"] = a[3:]
	
	if play_command == 'test' or play_command == 'auto-test':
		play_env["id"] = 'test'

	
	if play_env["id"] is not '':
		print "~ framework ID is %s" % play_env["id"]
	print "~"

	def check_jpda():
		jpda_port = play_app.readConf('jpda_port')
		try:
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.bind(('127.0.0.1', int(jpda_port)))
			s.close()
		except socket.error, e:
			print 'JPDA port %s is already used. Will try to use any free port for debugging' % jpda_port
			jpda_port = 0
	
	# ~~~~~~~~~~~~~~~~~~~~~~~ Build java path
	def do_java(className='play.server.Server'):
		global java_cmd
		global java_path
		global pid_path
		global application_mode
		global jpda_port
		global log_path
		
		# ~~~~~~~~~~~~~~~~~~~~~~ JAVA_HOME/bin/java is used if defined
		if not os.environ.has_key('JAVA_HOME'):
			java_path = "java"
		else:
			java_path = os.path.normpath("%s/bin/java" % os.environ['JAVA_HOME'])
		
		for a in remaining_args:
			if a.find('--with') == 0:
				remaining_args.remove(a)
			if a.find('--%') == 0:
				remaining_args.remove(a)
		# ~~~~~~~~~~~~~~~~~~~~~~ Read some configuration from conf/application.conf
		java_args = remaining_args[:]
		
		memory_in_args=False
		for arg in java_args:
			if arg.startswith('-Xm'):
				memory_in_args=True
		if not memory_in_args:
			memory = play_app.readConf('jvm.memory')
			if memory:
				java_args = java_args + memory.split(' ')
		
		jpda_port = play_app.readConf('jpda.port')
		
		application_mode = play_app.readConf('application.mode')
		
		if application_mode == 'prod':
			java_args.append('-server')
		
		java_policy = play_app.readConf('java.policy')
		if not java_policy == '':
			policyFile = os.path.join(application_path, 'conf', java_policy)
			if os.path.exists(policyFile):
				print "~ using policy file \"%s\"" % policyFile
				java_args.append('-Djava.security.manager')
				java_args.append('-Djava.security.policy==%s' % policyFile)
		
		# The Java stuff
		java_cmd = [java_path, '-javaagent:%s' % agent_path] + java_args + ['-classpath', cp_args, '-Dapplication.path=%s' % application_path, '-Dplay.id=%s' % play_env["id"], className]

		if not os.environ.has_key('PLAY_PID_PATH'):
			pid_path = os.path.join(application_path, 'server.pid');
		else:
			pid_path = os.environ['PLAY_PID_PATH'];
		
		if not os.environ.has_key('PLAY_LOG_PATH'):
			log_path = os.path.join(application_path, 'logs');
		else:
			log_path = os.environ['PLAY_LOG_PATH'];
		
		if not os.path.exists(log_path):
			os.mkdir(log_path);

	
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# ~~~~~~~~~~~~~~~~~~~~~~ The commands ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	if play_command in cmdloader.commands:
		cmdloader.commands[play_command].execute(
			command=play_command,
			app=play_app,
			args=remaining_args,
			env=play_env)
		sys.exit(0)

	# ~~~~~~~~~~~~~~~~~~~~~~ [id] Define the framework ID
	if play_command == 'id':
		if not play_env["id"]:
			print "~ framework ID is not set"
		new_id = raw_input("~ What is the new framework ID (or blank to unset)? ")
		if new_id:
			print "~"
			print "~ OK, the framework ID is now %s" % new_id
			print "~"
			open(id_file, 'w').write(new_id)
		else:
			print "~"
			print "~ OK, the framework ID is unset"
			print "~"
			if os.path.exists(id_file):
				os.remove(id_file)
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [new] Create a new application
	if play_command == 'new' or play_command == 'new,run':
		withModules = []
		application_name = None
		try:
			optlist, args = getopt.getopt(remaining_args, '', ['with=', 'name='])
			for o, a in optlist:
				if o in ('--with'):
					withModules = a.split(',')
				if o in ('--name'):
					application_name = a
		except getopt.GetoptError, err:
			print "~ %s" % str(err)
			print "~ Sorry, unrecognized option"
			print "~ "
			sys.exit(-1)
		if os.path.exists(application_path):
			print "~ Oops. %s already exists" % application_path
			print "~"
			sys.exit(-1)
		
		md = []
		for m in withModules:
			dirname = None
			if os.path.exists(os.path.join(play_env["basedir"], 'modules/%s' % m)) and os.path.isdir(os.path.join(play_env["basedir"], 'modules/%s' % m)):
				dirname = m
			else:
				for f in os.listdir(os.path.join(play_env["basedir"], 'modules')):
					if os.path.isdir(os.path.join(play_env["basedir"], 'modules/%s' % f)) and f.find('%s-' % m) == 0:
						dirname = f
						break
			
			if not dirname:
				print "~ Oops. No module %s found" % m
				print "~ Try to install it using 'play install %s'" % m
				print "~"
				sys.exit(-1)
			
			md.append(dirname)
			
		print "~ The new application will be created in %s" % os.path.normpath(application_path)
		if application_name is None:
		    application_name = raw_input("~ What is the application name? ")
		shutil.copytree(os.path.join(play_env["basedir"], 'resources/application-skel'), application_path)
		check_application()
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'%APPLICATION_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'%SECRET_KEY%', secretKey())
		print "~"
		
		for m in md:
			mn = m
			if mn.find('-') > 0:
				mn = mn[:mn.find('-')]
			replaceAll(os.path.join(application_path, 'conf/application.conf'), r'# ---- MODULES ----', '# ---- MODULES ----\nmodule.%s=${play.path}/modules/%s' % (mn, m) )
		
		# modules
		check_application()
		load_modules()
		for module in modules:
			commands = os.path.join(module, 'commands.py')
			if os.path.exists(commands):
				execfile(commands)
		
		print "~ OK, the application is created."
		print "~ Start it with : play run %s" % sys.argv[2]
		print "~ Have fun!"
		print "~"
		if play_command == 'new': sys.exit(0)
		
	# ~~~~~~~~~~~~~~~~~~~~~~ [new-module] Create a new module
	if play_command == 'new-module':
		if os.path.exists(application_path):
			print "~ Oops. %s already exists" % application_path
			print "~"
			sys.exit(-1)
			
		print "~ The new module will be created in %s" % os.path.normpath(application_path)
		print "~"
		application_name = os.path.basename(application_path)
		shutil.copytree(os.path.join(play_env["basedir"], 'resources/module-skel'), application_path)
		# check_application()
		replaceAll(os.path.join(application_path, 'build.xml'), r'%MODULE%', application_name)
		replaceAll(os.path.join(application_path, 'conf/messages'), r'%MODULE%', application_name)
		replaceAll(os.path.join(application_path, 'conf/routes'), r'%MODULE%', application_name)
		replaceAll(os.path.join(application_path, 'conf/routes'), r'%MODULE_LOWERCASE%', string.lower(application_name))
		os.mkdir(os.path.join(application_path, 'app/controllers/%s' % application_name))
		os.mkdir(os.path.join(application_path, 'app/models/%s' % application_name))
		os.mkdir(os.path.join(application_path, 'app/views/%s' % application_name))
		os.mkdir(os.path.join(application_path, 'app/views/tags/%s' % application_name))
		os.mkdir(os.path.join(application_path, 'src/play/modules/%s' % application_name))
		
		print "~ OK, the module is created."
		print "~ Start using it by adding this line in the application.conf modules list: "
		print "~ module.%s=%s" % (application_name, os.path.normpath(application_path))
		print "~"
		print "~ Have fun!"
		print "~"
		
		sys.exit(0)
		

	# ~~~~~~~~~~~~~~~~~~~~~~ [secret] Generate a new secret key
	if play_command == 'secret':
		check_application()
		print "~ Generating the secret key..."
		sk = secretKey()
		replaceAll(os.path.join(application_path, 'conf/application.conf'), r'application.secret=.*', 'application.secret=%s' % sk)
		print "~ Keep the secret : %s" % sk
		print "~"
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [status] Get application status
	if play_command == 'status' or play_command == 'st':
		url = ''
		secret_key = ''

		try:
			optlist, args = getopt.getopt(remaining_args, '', ['url=', 'secret='])
			for o, a in optlist:
				if o in ('--url'):
					if a.endswith('/'):
						url = a + '@status'
					else:
						url = a + '/@status'
				if o in ('--secret'):
					secret_key = a
		except getopt.GetoptError, err:
			print "~ %s" % str(err)
			print "~ "
			sys.exit(-1)
		
		if not url or not secret_key:
			check_application()
			if not url:
				http_port = int(play_app.readConf('http.port'))
				url = 'http://localhost:%s/@status' % http_port
			if not secret_key:
				secret_key = play_app.readConf('application.secret')
		
		import hmac
		from hashlib import sha1 as sha
		
		hm = hmac.new(secret_key, '@status', sha)
		authorization = hm.hexdigest()
		
		try:
			proxy_handler = urllib2.ProxyHandler({})
			req = urllib2.Request(url)
			req.add_header('Authorization', authorization)
			opener = urllib2.build_opener(proxy_handler)
			status = opener.open(req);
			print '~ Status from %s,' % url
			print '~'
			print status.read()
			print '~'
		except urllib2.HTTPError, e:
			print "~ Cannot retrieve the application status... (%s)" % (e.code)
			print "~"
			sys.exit(-1)
		except urllib2.URLError, e:
			print "~ Cannot contact the application..."
			print "~"
			sys.exit(-1)
		print
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [precompile] Precompile
	if play_command == 'precompile':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if os.path.exists(os.path.join(application_path, 'tmp')):
			shutil.rmtree(os.path.join(application_path, 'tmp'))
		if os.path.exists(os.path.join(application_path, 'precompiled')):
			shutil.rmtree(os.path.join(application_path, 'precompiled'))
		java_cmd.insert(2, '-Dprecompile=yes')
		try:
			subprocess.call(java_cmd, env=os.environ)
		except OSError:
			print "Could not execute the java executable, please make sure the JAVA_HOME environment variable is set properly (the java executable should reside at JAVA_HOME/bin/java). "
			sys.exit(-1)
		print
		sys.exit(0)


	# ~~~~~~~~~~~~~~~~~~~~~~ [out] Follow logs of the running application
	if play_command == 'out':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if not os.path.exists(os.path.join(log_path, 'system.out')):
			print "~ Oops! %s not found" % os.path.normpath(os.path.join(log_path, 'system.out'))
			print "~"
			sys.exit(-1)
		sout = open(os.path.join(log_path, 'system.out'), 'r')
		try:
			sout.seek(-5000, os.SEEK_END)
		except IOError:
			sout.seek(0)
		while True:
			where = sout.tell()
			line = sout.readline().strip()
			if not line:
				time.sleep(1)
				sout.seek(where)
			else:
				print line

	# ~~~~~~~~~~~~~~~~~~~~~~ [javadoc] Generates the javadoc for the project
	if play_command == 'jd' or play_command == 'javadoc':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		if not os.environ.has_key('JAVA_HOME'):
			javadoc_path = "javadoc"
		else:
			javadoc_path = os.path.normpath("%s/bin/javadoc" % os.environ['JAVA_HOME'])

		fileList = []
		def add_java_files(app_path):
			for root, subFolders, files in os.walk(os.path.join(app_path, 'app')):
				for file in files:
					if file.endswith(".java"):
						fileList.append(os.path.join(root, file))
		add_java_files(application_path)
		for module in modules:
			add_java_files(os.path.normpath(module))
		outdir = os.path.join(application_path, 'javadoc')
		sout = open(os.path.join(log_path, 'javadoc.log'), 'w')
		serr = open(os.path.join(log_path, 'javadoc.err'), 'w')
		if (os.path.isdir(outdir)):
			shutil.rmtree(outdir)
		javadoc_cmd = [javadoc_path, '-classpath', cp_args, '-d', outdir] + fileList
		print "Generating Javadoc in " + outdir + "..."
		subprocess.call(javadoc_cmd, env=os.environ, stdout=sout, stderr=serr)
		print "Done! You can open " + os.path.join(outdir, 'overview-tree.html') + " in your browser."
		sys.exit(0)

	# ~~~~~~~~~~~~~~~~~~~~~~ [netbeansify] Create netbeans configuration files
	if play_command == 'nb' or play_command == 'netbeansify':
		check_application()
		load_modules()
		do_classpath()
		application_name = play_app.readConf('application.name')
		if not application_name:
			application_name = os.path.dirname(application_path)
		nbproject = os.path.join(application_path, 'nbproject')
		if os.path.exists(nbproject):
			shutil.rmtree(nbproject)
			if os.name == 'nt':
				time.sleep(1)
		shutil.copytree(os.path.join(play_env["basedir"], 'resources/_nbproject'), nbproject)
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%APPLICATION_NAME%', application_name)
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%ANT_SCRIPT%', os.path.normpath(os.path.join(play_env["basedir"], 'framework/build.xml')))
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%APPLICATION_PATH%', os.path.normpath(application_path))
		if os.name == 'nt':
			replaceAll(os.path.join(nbproject, 'project.xml'), r'%PLAY_CLASSPATH%', ';'.join(classpath + ['nbproject\\classes']))
		else:
			replaceAll(os.path.join(nbproject, 'project.xml'), r'%PLAY_CLASSPATH%', ':'.join(classpath + ['nbproject/classes']))
		mr = ""
		for module in modules:
			mr += "<package-root>%s</package-root>" % os.path.normpath(os.path.join(module, 'app'))
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%MODULES%', mr)
		mr = ""
		for dir in os.listdir(application_path):
			if os.path.isdir(os.path.join(application_path, dir)) and dir not in ['app', 'conf', 'test', 'test-result', 'public', 'tmp', 'logs', 'nbproject', 'lib']:
				mr = '<source-folder style="tree"><label>%s</label><location>%s</location></source-folder>' % (dir, dir)
		replaceAll(os.path.join(nbproject, 'project.xml'), r'%MORE%', mr)
		print "~ OK, the application is ready for netbeans"
		print "~ Just open %s as a netbeans project" % os.path.normpath(application_path)
		print "~"
		print "~ Use netbeansify again when you want to update netbeans configuration files, then close and open you project again."
		print "~"
		sys.exit(0)

	
	# ~~~~~~~~~~~~~~~~~~~~~~ [eclipsify] Create eclipse configuration files
	if play_command == 'ec' or play_command == 'eclipsify':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		application_name = play_app.readConf('application.name')
		if not application_name:
			application_name = os.path.dirname(application_path)
		dotProject = os.path.join(application_path, '.project')
		dotClasspath = os.path.join(application_path, '.classpath')
		dotSettings = os.path.join(application_path, '.settings')
		eclipse = os.path.join(application_path, 'eclipse')
		if os.path.exists(eclipse):
			shutil.rmtree(eclipse)
			if os.name == 'nt':
				time.sleep(1)
		
		if os.path.exists(dotSettings):
			shutil.rmtree(dotSettings)
			if os.name == 'nt':
				time.sleep(1)
		
		shutil.copyfile(os.path.join(play_env["basedir"], 'resources/eclipse/.project'), dotProject)
		shutil.copyfile(os.path.join(play_env["basedir"], 'resources/eclipse/.classpath'), dotClasspath)
		shutil.copytree(os.path.join(play_env["basedir"], 'resources/eclipse'), eclipse)
		shutil.copytree(os.path.join(play_env["basedir"], 'resources/eclipse/.settings'), dotSettings)
		replaceAll(dotProject, r'%PROJECT_NAME%', application_name)
		
		playJarPath = os.path.join(play_env["basedir"], 'framework','play.jar')
		playSourcePath = os.path.dirname(playJarPath)
		if os.name == 'nt':
			playSourcePath=playSourcePath.replace('\\','/').capitalize()
		
		cpXML = ""
		for el in classpath:
			if not os.path.basename(el) == "conf":
				if el == playJarPath:
					cpXML += '<classpathentry kind="lib" path="%s" sourcepath="%s" />\n\t' % (os.path.normpath(el) , playSourcePath)
				else:
					cpXML += '<classpathentry kind="lib" path="%s" />\n\t' % os.path.normpath(el)
		replaceAll(dotClasspath, r'%PROJECTCLASSPATH%', cpXML)
		
		if len(modules):
			lXML = ""
			cXML = ""
			for module in modules:
				lXML += '<link><name>%s</name><type>2</type><location>%s</location></link>\n' % (os.path.basename(module), os.path.join(module, 'app').replace('\\', '/'))
				if os.path.exists(os.path.join(module, "conf")):
					lXML += '<link><name>conf/%s</name><type>2</type><location>%s/conf</location></link>\n' % (os.path.basename(module), module.replace('\\', '/'))
				if os.path.exists(os.path.join(module, "public")):
					lXML += '<link><name>public/%s</name><type>2</type><location>%s/public</location></link>\n' % (os.path.basename(module), module.replace('\\', '/'))
				cXML += '<classpathentry kind="src" path="%s"/>' % (os.path.basename(module))
			replaceAll(dotProject, r'%LINKS%', '<linkedResources>%s</linkedResources>' % lXML)
			replaceAll(dotClasspath, r'%MODULES%', cXML)
		else:
			replaceAll(dotProject, r'%LINKS%', '')
			replaceAll(dotClasspath, r'%MODULES%', '')
		
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%PROJECT_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%PLAY_BASE%', play_env["basedir"])
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%PLAY_ID%', play_env["id"])
		replaceAll(os.path.join(application_path, 'eclipse/debug.launch'), r'%JPDA_PORT%', jpda_port)
		
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%PROJECT_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%PLAY_BASE%', play_env["basedir"])
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%PLAY_ID%', play_env["id"])
		replaceAll(os.path.join(application_path, 'eclipse/test.launch'), r'%JPDA_PORT%', jpda_port)
		
		replaceAll(os.path.join(application_path, 'eclipse/connect.launch'), r'%PROJECT_NAME%', application_name)
		replaceAll(os.path.join(application_path, 'eclipse/connect.launch'), r'%JPDA_PORT%', jpda_port)
		
		os.rename(os.path.join(application_path, 'eclipse/connect.launch'), os.path.join(application_path, 'eclipse/Connect JPDA to %s.launch' % application_name))
		os.rename(os.path.join(application_path, 'eclipse/test.launch'), os.path.join(application_path, 'eclipse/Test %s.launch' % application_name))
		os.rename(os.path.join(application_path, 'eclipse/debug.launch'), os.path.join(application_path, 'eclipse/%s.launch' % application_name))
		
		# Module-specific modifications
		for module in modules:
			commands = os.path.join(module, 'commands.py')
			if os.path.exists(commands):
				execfile(commands)
		
		print "~ OK, the application is ready for eclipse"
		print "~ Use File/Import/General/Existing project to import %s into eclipse" % os.path.normpath(application_path)
		print "~"
		print "~ Use eclipsify again when you want to update eclipse configuration files."
		print "~ However, it's often better to delete and re-import the project into your workspace since eclipse keeps dirty caches..."
		print "~"
		
		sys.exit(0)

	# ~~~~~~~~~~~~~~~~~~~~~~ [idealize] Create idea intellij configuration files
	if play_command == 'idea' or play_command == 'idealize':
		check_application()
		load_modules()
		do_classpath()
		do_java()
		application_name = play_app.readConf('application.name')
		imlFile = os.path.join(application_path, application_name + '.iml')
		shutil.copyfile(os.path.join(play_env["basedir"], 'resources/idea/imlTemplate.xml'), imlFile)
		cpXML = ""
		
		replaceAll(imlFile, r'%PLAYHOME%', play_env["basedir"].replace('\\', '/'))
		
		if len(modules):
			lXML = ""
			cXML = ""
			for module in modules:
				lXML += '    <content url="file://%s">\n      <sourceFolder url="file://%s" isTestSource="false" />\n    </content>\n' % (module, os.path.join(module, 'app').replace('\\', '/'))
			replaceAll(imlFile, r'%LINKS%', lXML)
		else:
			replaceAll(imlFile, r'%LINKS%', '')
		
		print "~ OK, the application is ready for Intellij Idea"
		print "~ Use File/New Module/Import Existing module"
		print "~"
		
		sys.exit(0)

	# Module command ?
	if play_command.find(':') > 0:
		app.check()
		for module in app.modules():
			commands = os.path.join(module, 'commands.py')
			if os.path.exists(commands):
				execfile(commands)


	# ~~~~~~~~~~~~~~~~~~~~~~ Invalid command
	print "~ Usage: play cmd [app_path] [--options]"
	print "~ "
	print "~ with,  new      Create a new application"
	print "~        run      Run the application in the current shell"
	print "~        help     Show play help"
	print "~"
	if len(sys.argv) > 1:
		print "~ Invalid command: %s" % sys.argv[1]
		print "~"
	sys.exit(-1)


except KeyboardInterrupt:
	print '~ ...'
	sys.exit(0)


